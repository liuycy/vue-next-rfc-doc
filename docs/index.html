<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Composition API RFC | Vue Composition API</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="./assets/css/0.styles.943fdd6d.css" as="style"><link rel="preload" href="./assets/js/app.4f95502a.js" as="script"><link rel="preload" href="./assets/js/2.857b4676.js" as="script"><link rel="preload" href="./assets/js/10.48447aef.js" as="script"><link rel="prefetch" href="./assets/js/11.1a2a9884.js"><link rel="prefetch" href="./assets/js/3.5e110c6a.js"><link rel="prefetch" href="./assets/js/4.b0dd307f.js"><link rel="prefetch" href="./assets/js/5.eae0a62b.js"><link rel="prefetch" href="./assets/js/6.992be560.js"><link rel="prefetch" href="./assets/js/7.f82366e2.js"><link rel="prefetch" href="./assets/js/8.a0db8fde.js"><link rel="prefetch" href="./assets/js/9.5f43fbd7.js">
    <link rel="stylesheet" href="./assets/css/0.styles.943fdd6d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-exact-active router-link-active"><!----> <span class="site-name">Vue Composition API</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./" class="nav-link router-link-exact-active router-link-active">
  Composition API RFC
</a></div><div class="nav-item"><a href="/./API.html" class="nav-link">
  API Reference
</a></div><div class="nav-item"><a href="/./RFCs/0001-new-slot-syntax.html" class="nav-link">
  RFCs
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./" class="nav-link router-link-exact-active router-link-active">
  Composition API RFC
</a></div><div class="nav-item"><a href="/./API.html" class="nav-link">
  API Reference
</a></div><div class="nav-item"><a href="/./RFCs/0001-new-slot-syntax.html" class="nav-link">
  RFCs
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Composition API RFC</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./#概要" class="sidebar-link">概要</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/./#基本用例" class="sidebar-link">基本用例</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/./#动机" class="sidebar-link">动机</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./#逻辑复用-代码组织" class="sidebar-link">逻辑复用 &amp; 代码组织</a></li><li class="sidebar-sub-header"><a href="/./#更好的类型推断" class="sidebar-link">更好的类型推断</a></li></ul></li><li><a href="/./#设计细节" class="sidebar-link">设计细节</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./#api-简介" class="sidebar-link">API 简介</a></li><li class="sidebar-sub-header"><a href="/./#代码组织" class="sidebar-link">代码组织</a></li><li class="sidebar-sub-header"><a href="/./#逻辑提取和复用" class="sidebar-link">逻辑提取和复用</a></li><li class="sidebar-sub-header"><a href="/./#与现有-api-一起使用" class="sidebar-link">与现有 API 一起使用</a></li><li class="sidebar-sub-header"><a href="/./#插件开发" class="sidebar-link">插件开发</a></li></ul></li><li><a href="/./#缺点" class="sidebar-link">缺点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./#引入-refs-的开销" class="sidebar-link">引入 Refs 的开销</a></li><li class="sidebar-sub-header"><a href="/./#ref-vs-reactive" class="sidebar-link">Ref vs. Reactive</a></li><li class="sidebar-sub-header"><a href="/./#冗长的返回语句" class="sidebar-link">冗长的返回语句</a></li><li class="sidebar-sub-header"><a href="/./#灵活性带来的制约需求" class="sidebar-link">灵活性带来的制约需求</a></li></ul></li><li><a href="/./#采用策略" class="sidebar-link">采用策略</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/./#附录" class="sidebar-link">附录</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./#class-api-的类型问题" class="sidebar-link">Class API 的类型问题</a></li><li class="sidebar-sub-header"><a href="/./#对比-react-hooks" class="sidebar-link">对比 React Hooks</a></li><li class="sidebar-sub-header"><a href="/./#对比-svelte" class="sidebar-link">对比 Svelte</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="composition-api-rfc"><a href="#composition-api-rfc" class="header-anchor">#</a> Composition API RFC</h1> <ul><li>开始日期: 2019-07-10</li> <li>目标版本: 2.x / 3.x</li> <li>参考 Issues: <a href="https://github.com/vuejs/rfcs/pull/42" target="_blank" rel="noopener noreferrer">#42<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>实现 PR: (留空)</li></ul> <blockquote><p>由于英文水平有限, 每次看<a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener noreferrer">原文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>都比较费劲, 所以参考<a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener noreferrer">尤雨溪在知乎上的翻译<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>简单翻译成中文, 方便下次阅读</p></blockquote> <h2 id="概要"><a href="#概要" class="header-anchor">#</a> 概要</h2> <p><strong>Composition API</strong> 简介: 一套允许灵活组合组件逻辑的附加的 API 函数.</p> <h2 id="基本用例"><a href="#基本用例" class="header-anchor">#</a> 基本用例</h2> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>increment<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    Count is: {{ state.count }}, double is: {{ state.double }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">,</span>
      increment
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="动机"><a href="#动机" class="header-anchor">#</a> 动机</h2> <h3 id="逻辑复用-代码组织"><a href="#逻辑复用-代码组织" class="header-anchor">#</a> 逻辑复用 &amp; 代码组织</h3> <p>Vue 容易上手, 方便构建中小型应用. 随着用户增长, 人们开始用 Vue 构建大型应用(多人合作长期迭代维护的那种). Vue 现有的 API 的限制会带来很多问题, 大致可以分为两类:</p> <ol><li><p>随着功能的迭代, 组件越来越复杂且难以读懂, 尤其是当你读别人写的代码时. 根本原因就是 Vue 现有 API 要求你使用选项来组织代码, 但有时根据逻辑关系组织代码更有意义</p></li> <li><p>缺少一种干净且无成本的机制来抽离和复用多个组件间的逻辑. (详见<a href="#%E9%80%BB%E8%BE%91%E6%8F%90%E5%8F%96%E5%92%8C%E5%A4%8D%E7%94%A8">逻辑提取和复用</a>)</p></li></ol> <p>RFC 中提出的 API 为用户组织代码提供更大的灵活性. 现在的 API 可以按功能将代码组织成函数片段, 不再要求写在选项里了, 而且让组件间或组件外的逻辑更容易抽离和复用.
具体实现请看<a href="#%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82">设计细节</a></p> <h3 id="更好的类型推断"><a href="#更好的类型推断" class="header-anchor">#</a> 更好的类型推断</h3> <p>在开发大型应用时, 开发者的另一个常见需求是支持 TypeScript. Vue 与 TypeScript 集成有点困难, 只要是因为 <code>this</code> 在 Vue 组件中比普通 JavaScript 多了一些属性
(例如: 在 <code>methods</code> 选项中定义的函数里 <code>this</code> 指向的是 Vue 组件实例, 而不是 <code>methods</code> 这个对象). 换言之, Vue 在设计之初没有考虑到类型推断, 导致现在与 TypeScript 结合很困难.</p> <p>现在大多数使用 TypeScript 写 Vue 的用户都在使用 <code>vue-class-component</code> 库, 一个使用 TypeScript Class (结合 decorators) 来定义组件的库.
在设计 3.0 之初, 我们原本打算提供一个内置 Class API 来更好地解决类型问题(详见<a href="https://github.com/vuejs/rfcs/pull/17" target="_blank" rel="noopener noreferrer">之前的 RFC(已废弃)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>).
但当我们讨论并迭代设计时, 发现使用 Class API 必须依赖 decorators (这是一个非常不稳定的 <code>stage 2</code> 提案, 在实现细节上仍有许多不确定性), 这会很冒险.
(更多细节请看<a href="#class-api-%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98">Class API 的类型问题</a>).</p> <p>相比之下, 这个 RFC 提出的 API 基本上使用的都是本身就类型友好的普通变量和函数, 使用这些 API 几乎不需要手写类型提示就能享受到完整的类型推断.
也就是说, 这些 API 用 TypeScript 或 JavaScript 写看起来都基本是一样的, 所以即使是非 TypeScript 用户也能从 IDE 自带的类型提示中受益.</p> <h2 id="设计细节"><a href="#设计细节" class="header-anchor">#</a> 设计细节</h2> <h3 id="api-简介"><a href="#api-简介" class="header-anchor">#</a> API 简介</h3> <p>这里提出的 API 没有引入新概念, 而是将 Vue 的核心功能(如: 创建和监听响应式属性)作为独立的函数暴露出来.
我们将介绍最基本的几个 API 以及如何使用它们代替 2.x 的选项. 注意本节主要介绍基本概念, 详细完整的 API 请查看<a href="/API">API Reference</a></p> <h4 id="响应式属性和副作用"><a href="#响应式属性和副作用" class="header-anchor">#</a> 响应式属性和副作用</h4> <p>从简单的任务开始: 声明一些响应式属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token comment">// 响应式属性</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>reactive</code> 相当于 2.x 的 <code>Vue.observable()</code>, 为防止与 RxJS 的 observables 冲突就改名叫 <code>reactive</code> 了.
这个函数返回的是一个 Vue 用户都相当熟悉的响应式对象.</p> <p>响应式属性最基本的用途就是在 Vue 渲染期间使用它, 由于依赖跟踪, 视图会在响应式属性改变时自动更新.
在 DOM 中渲染一些东西可以被视为一种&quot;副作用&quot;(程序在修改程序外部的状态).
要根据响应式属性来触发和重新触发一种副作用的话, 我们需要用到 <code>watch</code> API:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> watch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">count is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>watch</code> 需要传入一个回调函数来触发副作用(在上例中, 设置 <code>innerHTML</code> 为副作用).
回调函数会立即被调用, 并将所有它用到的响应式属性作为依赖跟踪. 在上例中, <code>state.count</code> 会在回调函数调用后被作为依赖跟踪.
将来 <code>state.count</code> 发生改变时, 回调函数会被再次调用.</p> <p>这就是 Vue 响应式系统的基本原理. 当你在组件的 <code>data()</code> 返回一个对象时, 在内部会调用 <code>reactive()</code> 将它变成响应式的.
使用这些响应式属性的模板会被编译成 render 函数 (可以认为是更高效的 <code>innerHTML</code>)</p> <p>继续上面这个例子, 我们加上处理用户输入的逻辑:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">.</span>count<span class="token operator">++</span>
<span class="token punctuation">}</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> increment<span class="token punctuation">)</span>
</code></pre></div><p>不过利用 Vue 的模板系统, 我们不必手写 innerHTML 或 事件监听的处理函数, 我们先用伪代码 <code>renderTemplate</code> 来简化一下例子, 把心思放在响应式这块:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> watch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">.</span>count<span class="token operator">++</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">,</span>
  increment
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 伪代码, 不是真实 API</span>
  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;{{ state.count }}&lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    renderContext
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="计算属性和-refs"><a href="#计算属性和-refs" class="header-anchor">#</a> 计算属性和 Refs</h4> <p>有时我们需要一个随其他状态变化而变化的属性 - 在 Vue 中, 这是通过 <em>计算属性</em> 来实现的.
我们现在可以使用 <code>computed</code> API 来直接创建一个计算属性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> double <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><p>上例中 <code>computed</code> 会返回什么 ? 我们猜猜看 <code>computed</code> 的内部逻辑, 可能是下面这样的:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简化版的伪代码</span>
<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> value
  <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    value <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre></div><p>但我们知道上面这代码是行不通的: 如果 <code>value</code> 是一个原始类型(如 <code>number</code>), 那么它跟 <code>computed</code> 内部更新逻辑之间的联系会在函数返回时丢失.
因为 JavaScript 的原始类型是通过值传递的, 不是引用:</p> <p><img src="https://www.mathwarehouse.com/programming/images/pass-by-reference-vs-pass-by-value-animation.gif" alt=""></p> <p>将值作为对象的属性再返回这个对象也是一样的, 没有用. 在函数返回时, 这些做法都不能保持这个值的响应式. 为了确保能始终拿到最新的值, 我们需要将值包装进一个对象中, 然后返回这个对象:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简化版的伪代码</span>
<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    ref<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> ref
<span class="token punctuation">}</span>
</code></pre></div><p>此外, 我们还需要拦截返回对象的 <code>.value</code> 属性的 读/写 操作来执行依赖跟踪和更新通知(为了简化, 例子中省略了这些代码).
现在我们通过引用来传递计算之后的值了, 不用再担心丢失响应性了. 代价就是我们需要通过 <code>.value</code> 来访问最新的值:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> double <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>double<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; 0</span>

state<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// -&gt; 2</span>
</code></pre></div><p>在上例中, 我们将 <code>double</code> 称为 <code>ref</code> 对象, 因为它是内部值的响应式引用.</p> <blockquote><p>想必你已经知道 Vue 中早就有 &quot;refs&quot; 的概念了, 但仅用于模板引用 DOM 节点或组件实例.
点击<a href="/./API.html#template-refs">这里</a>了解新的 refs 系统是如何同时被用于逻辑属性和模板引用的.</p></blockquote> <p>除了 computed ref, 我们还可以用 <code>ref</code> API 直接创建一个普通的可变 ref:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>

count<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><h4 id="ref-展开"><a href="#ref-展开" class="header-anchor">#</a> Ref 展开</h4> <div><p>我们可以将 ref 暴露到 render 上下文中. Vue 内部会对 ref 做特殊处理, 以便 render 上下文能直接拿到 ref 的内部值.
也就是说, 在模板中我们可以直接写 <code>{{ count }}</code>, 不需要写 <code>{{ count.value }}</code>了.</p></div><p>我们稍微改一下之前的 counter 的例子, 用 ref 代替 reactive:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  count<span class="token punctuation">.</span>value<span class="token operator">++</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  count<span class="token punctuation">,</span>
  increment
<span class="token punctuation">}</span>

<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;{{ count }}&lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    renderContext
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>另外, 当一个 ref 作为属性嵌套在一个 reactive 对象中, 它也会自动展开:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 不需要使用 `state.double.value`</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>double<span class="token punctuation">)</span>
</code></pre></div><h4 id="在组件中使用"><a href="#在组件中使用" class="header-anchor">#</a> 在组件中使用</h4> <p>到目前为止, 我们的 UI 代码可以根据用户的输入进行更新了 - 不过代码并不能复用.
如果我们想复用代码逻辑, 下一步应该将其重构成一个函数:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed<span class="token punctuation">,</span> watch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>count<span class="token operator">++</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">,</span>
    increment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;
      Count is: {{ state.count }}, double is: {{ state.double }}
    &lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    renderContext
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>注意上例中的代码并没有依赖组件示例. 实际上, 目前为止介绍的所有 API 都可以脱离组件实例直接使用, 这样可以在更多场景下使用 Vue 的响应式系统.</p></blockquote> <p>现在我们将 调用 <code>setup()</code>、创建监听函数 和 渲染模板 的任务交给框架, 只用 <code>setup()</code> 和 模板 来定义一个组件:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>increment<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    Count is: {{ state.count }}, double is: {{ state.double }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">,</span>
      increment
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这是我们熟悉的单文件组件, 只有逻辑部分(<code>&lt;script&gt;</code>)和以前不太一样, 模板语法和以前一样, <code>&lt;style&gt;</code>省略了, 但也和以前一样.</p> <h4 id="生命周期钩子"><a href="#生命周期钩子" class="header-anchor">#</a> 生命周期钩子</h4> <p>到目前为止, 我们已经介绍了组件的纯状态部分: 响应式属性、计算属性和用户输入相关的属性变化.
但是组件可能还要处理副作用 - 例如: 打印到控制台、发送 ajax 请求 或 在 <code>window</code> 上设置一个监听事件.
这些副作用通常在以下时刻发生:</p> <ul><li>某些属性改变时</li> <li>组件<code>mounted</code>、<code>updated</code>或<code>unmounted</code>时(生命周期钩子)</li></ul> <p>我们已经知道可以使用 <code>watch</code> API 来触发属性改变时的副作用了.
至于生命周期钩子中的副作用, 我们可以用 <code>onXXX</code> API (对应现有的生命周期选项) 来触发:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'component is mounted!'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些生命周期注册函数只能在 <code>setup</code> 内使用, 它会利用内部全局属性自动找出正在调用 <code>setup</code> 的当前组件实例.
这样设计是为了减少将逻辑提取到外部函数时的摩擦.</p> <blockquote><p>关于 API 的更多细节请查看<a href="/API">API Reference</a>, 不过我们建议你先看完下面的内容.</p></blockquote> <h3 id="代码组织"><a href="#代码组织" class="header-anchor">#</a> 代码组织</h3> <p>至此, 我们已经用导入的函数取代了组件 API, 为了什么呢? 用选项定义组件似乎要比将所有功能混合在一起更有组织性!</p> <p>咋一看确实如此. 但正如动机部分所述, 我们认为 Composition API 实际上可以更好地组织代码, 尤其是在复杂的组件中. 我们现在来解释为什么.</p> <h4 id="什么是-有组织的代码"><a href="#什么是-有组织的代码" class="header-anchor">#</a> 什么是&quot;有组织的代码&quot;</h4> <p>我们回想一下到底什么才是&quot;有组织的代码&quot;. 编写有组织的代码的目的就是让代码更容易阅读和理解.
要如何才能做到&quot;理解&quot;代码? 仅凭组件中包含了哪些选项就能说我们&quot;理解&quot;它了吗?
你有看过其他开发者写的大型组件吗(比如<a href="https://github.com/vuejs/vue-cli/blob/dev/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404" target="_blank" rel="noopener noreferrer">这个<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>), 看懂了吗?</p> <p>想想你要怎么跟你的同事梳理类似上面链接中的大型组件的逻辑. 你很可能会从&quot;这个组件会处理 X, Y 和 Z&quot;说起, 而不是&quot;这个组件有哪些数据, 计算属性和方法&quot;.
在理解组件时, 我们更在意&quot;组件试图做什么&quot;(即代码背后的意图), 而不是&quot;这个组件用了哪些选项&quot;. 基于选项的 API 自然可以回答后者, 但却很难解释前者.</p> <h4 id="逻辑关注点-vs-选项类型"><a href="#逻辑关注点-vs-选项类型" class="header-anchor">#</a> 逻辑关注点 vs 选项类型</h4> <p>我们将组件处理的&quot;X, Y 和 Z&quot;定义为<strong>逻辑关注点</strong>. 小型单一的组件通常不存在可读性问题, 因为整个组件就处理一个关注点.
但在高级点的使用场景下这个问题就会变得很突出, 比如<a href="https://github.com/vuejs/vue-cli/blob/dev/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404" target="_blank" rel="noopener noreferrer">Vue CLI UI file explorer<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
这个组件, 需要处理许多不同的逻辑关注点:</p> <ul><li>跟踪当前文件夹状态</li> <li>处理文件夹导航(打开, 关闭, 刷新...)</li> <li>处理新文件夹的创建</li> <li>是否只显示收藏夹</li> <li>是否显示隐藏文件夹</li> <li>处理当前工作目录的修改</li></ul> <p>如果你在阅读基于选项 API 的代码, 你肯定很难立刻找出并区分这些逻辑关注点. 你会看到同一个功能被拆的到处都是, &quot;创建新文件夹&quot;功能用了两个数据属性，一个计算属性和一个方法, 而且方法定义在属性下面一百多行的地方.
如果我们用颜色标记一下同一个功能, 你就会发现它们非常分散:</p> <div style="text-align:center;"><img src="https://user-images.githubusercontent.com/499550/62783021-7ce24400-ba89-11e9-9dd3-36f4f6b1fae2.png"></div> <p>这样会导致复杂的组件变得很难理解和维护, 选项把逻辑强制拆分. 通过选项强行拆分会导致逻辑关注点变得模糊, 而且我们在处理同一个功能时, 需要在不同的选项间跳来跳去.</p> <blockquote><p>注意: 提供的这个例子是截至我们编写这篇文章为止的最新代码, 没有任何修改, 源代码现在可能会有些许的改动.</p></blockquote> <p>是时候表演真正的技术啦, 现在我们用 <code>Composition API</code> 来改写这个例子中的&quot;新建文件夹&quot;功能:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useCreateFolder</span> <span class="token punctuation">(</span><span class="token parameter">openFolder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 原本在 data() 里面定义的属性</span>
  <span class="token keyword">const</span> showNewFolder <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> newFolderName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>

  <span class="token comment">// 原本在 computed 里面定义的计算属性</span>
  <span class="token keyword">const</span> newFolderValid <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">isValidMultiName</span><span class="token punctuation">(</span>newFolderName<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// 原本在 method 里面定义的方法</span>
  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">createFolder</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newFolderValid<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      mutation<span class="token operator">:</span> <span class="token constant">FOLDER_CREATE</span><span class="token punctuation">,</span>
      variables<span class="token operator">:</span> <span class="token punctuation">{</span>
        name<span class="token operator">:</span> newFolderName<span class="token punctuation">.</span>value
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">openFolder</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">.</span>folderCreate<span class="token punctuation">.</span>path<span class="token punctuation">)</span>
    newFolderName<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">''</span>
    showNewFolder<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    showNewFolder<span class="token punctuation">,</span>
    newFolderName<span class="token punctuation">,</span>
    newFolderValid<span class="token punctuation">,</span>
    createFolder
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在新建文件夹的功能全部写在一个函数里, 从函数名称就能看出这个函数是做什么的, 这就是我们说的<strong>组合函数</strong>.
建议定义组合函数时函数名用<code>use</code>开头, 以此类推我们可以把各个逻辑关注点改成组合函数.
</p><div><img src="https://user-images.githubusercontent.com/499550/62783026-810e6180-ba89-11e9-8774-e7771c8095d6.png"></div><p></p> <blockquote><p>上图中不包含 <code>import</code>语句 和 <code>setup()</code>函数, 改造后的完整代码可以查看<a href="https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>每个逻辑关注点都写到一个函数里了, 可以不用再跳来跳去了. 组合函数再编辑器里还能折叠起来方便浏览:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useCurrentFolderData</span><span class="token punctuation">(</span><span class="token parameter">networkState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useFolderNavigation</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> networkState<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useFavoriteFolder</span><span class="token punctuation">(</span><span class="token parameter">currentFolderData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useHiddenFolders</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useCreateFolder</span><span class="token punctuation">(</span><span class="token parameter">openFolder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>setup()</code>函数是所有组合函数的入口点:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 网络相关</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> networkState <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useNetworkState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 文件夹相关</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> folders<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useCurrentFolderData</span><span class="token punctuation">(</span>networkState<span class="token punctuation">)</span>
    <span class="token keyword">const</span> folderNavigation <span class="token operator">=</span> <span class="token function">useFolderNavigation</span><span class="token punctuation">(</span><span class="token punctuation">{</span> networkState<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> favoriteFolders<span class="token punctuation">,</span> toggleFavorite <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFavoriteFolders</span><span class="token punctuation">(</span>currentFolderData<span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> showHiddenFolders <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useHiddenFolders</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> createFolder <span class="token operator">=</span> <span class="token function">useCreateFolder</span><span class="token punctuation">(</span>folderNavigation<span class="token punctuation">.</span>openFolder<span class="token punctuation">)</span>

    <span class="token comment">// 当前工作目录相关</span>
    <span class="token function">resetCwdOnLeave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> updateOnCwdChanged <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useCwdUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 工具函数</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> slicePath <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">usePathUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      networkState<span class="token punctuation">,</span>
      folders<span class="token punctuation">,</span>
      currentFolderData<span class="token punctuation">,</span>
      folderNavigation<span class="token punctuation">,</span>
      favoriteFolders<span class="token punctuation">,</span>
      toggleFavorite<span class="token punctuation">,</span>
      showHiddenFolders<span class="token punctuation">,</span>
      createFolder<span class="token punctuation">,</span>
      updateOnCwdChanged<span class="token punctuation">,</span>
      slicePath
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>没错, 用选项 API 的话不用写那么多, 但是<code>setup()</code>函数读起来就像这个组件试图做什么——选项 API 读起来就没有这种感觉.
通过参数传递, 你会很清楚组合函数之间的关系. 还有, <code>return</code>语句是唯一可以检查函数暴露了什么参数给模板的地方.</p> <p>同一个功能, 可以用 <code>选项 API</code> 也可以用 <code>组合函数 API</code>, 选项 API 更具强制性, 而组合API 更关注逻辑.</p> <h3 id="逻辑提取和复用"><a href="#逻辑提取和复用" class="header-anchor">#</a> 逻辑提取和复用</h3> <p>在组件间提取和复用逻辑的话, 组合 API 非常灵活好用. 不需要再依赖神奇的<code>this</code>上下文, 它只依赖传入的参数和全局的 Vue API.
你可以把任何你想复用的组件逻辑导出为一个函数. 你甚至可以导出整个<code>setup()</code>来实现<code>extend</code>的功能.</p> <p>举个例子: 实现跟踪鼠标的位置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX
    y<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY
  <span class="token punctuation">}</span>

  <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>组件可以导入这个函数:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useMousePosition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./mouse'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 其它逻辑 .. </span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在文件夹的例子中, 我们提取了一些通用的代码(比如: <code>usePathUtils</code> 和 <code>useCwdUtils</code>)到外部文件中, 因为在其它文件也能用到.
其实用 <code>mixins</code>, <code>高阶组件</code>或<code>无渲染组件(通过插槽)</code>也能实现逻辑复用, 网上有很多教程这里不再赘述了. 但与组合函数相比, 这些方法都有各自的缺点:</p> <ul><li>渲染上下文中的属性来源不明确. 例如: 使用了多个<code>mixins</code>的组件在渲染模板时, 很难分清某个属性是从哪个<code>mixins</code>注入的</li> <li>命名空间冲突. <code>mixins</code>可能会有属性名或方法名的冲突, 高阶组件可能会有 props 名的冲突</li> <li>性能. 高阶组件和无渲染组件需要创建一个有状态的组件, 这会造成性能损失
相比之下, 使用组合 API :</li> <li>暴露给模板的属性来源清晰, 因为都是来自组合函数的</li> <li>不存在命名空间的冲突, 组合函数的返回值可以随便重命名</li> <li>复用逻辑不用创建不必要的组件</li></ul> <h3 id="与现有-api-一起使用"><a href="#与现有-api-一起使用" class="header-anchor">#</a> 与现有 API 一起使用</h3> <p>组合 API 可以与现有的 API 一起使用.</p> <ul><li>组合 API 会比 2.x 的选项(<code>data</code>, <code>computed</code> 和 <code>methods</code>)先解析完, 所以在组合 API 内访问不到选项定义的属性和方法.</li> <li><code>setup()</code> retrun 的属性会暴露在 <code>this</code> 上, 选项 API 可以访问.</li></ul> <h3 id="插件开发"><a href="#插件开发" class="header-anchor">#</a> 插件开发</h3> <p>许多插件会将属性注入到<code>this</code>上. 例如: Vue Router 会注入<code>this.$route</code>和<code>this.$router</code>, Vuex 会注入<code>this.$route</code>.
这就让类型推断变得很棘手, 因为每一个插件都要为注入的属性添加类型到 Vue.</p> <p>当你使用组合 API 时, 没有<code>this</code>了, 插件可以通过内部调用 <a href="/./API.html#provide-inject"><code>provide</code> &amp; <code>inject</code></a> 提供组合函数, 举个例子:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> StoreSymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">provideStore</span><span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">provide</span><span class="token punctuation">(</span>StoreSymbol<span class="token punctuation">,</span> store<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>StoreSymbol<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里可以报错, 没有获取到 store</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> store
<span class="token punctuation">}</span>
</code></pre></div><p>在业务代码中:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在根组件中提供 store</span>
<span class="token comment">//</span>
<span class="token keyword">const</span> App <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">provideStore</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> Child <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 在这里使用 store</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意, <code>store</code> 也可以通过 app 级别的 全局 API 提供, 但在业务代码中 <code>useStore</code> 内的代码不需要改变.</p> <h2 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h2> <h3 id="引入-refs-的开销"><a href="#引入-refs-的开销" class="header-anchor">#</a> 引入 Refs 的开销</h3> <h3 id="ref-vs-reactive"><a href="#ref-vs-reactive" class="header-anchor">#</a> Ref vs. Reactive</h3> <h3 id="冗长的返回语句"><a href="#冗长的返回语句" class="header-anchor">#</a> 冗长的返回语句</h3> <h3 id="灵活性带来的制约需求"><a href="#灵活性带来的制约需求" class="header-anchor">#</a> 灵活性带来的制约需求</h3> <h2 id="采用策略"><a href="#采用策略" class="header-anchor">#</a> 采用策略</h2> <h2 id="附录"><a href="#附录" class="header-anchor">#</a> 附录</h2> <h3 id="class-api-的类型问题"><a href="#class-api-的类型问题" class="header-anchor">#</a> Class API 的类型问题</h3> <h3 id="对比-react-hooks"><a href="#对比-react-hooks" class="header-anchor">#</a> 对比 React Hooks</h3> <h3 id="对比-svelte"><a href="#对比-svelte" class="header-anchor">#</a> 对比 Svelte</h3></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.4f95502a.js" defer></script><script src="./assets/js/2.857b4676.js" defer></script><script src="./assets/js/10.48447aef.js" defer></script>
  </body>
</html>
