<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>API 文档 | Vue Composition API</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/vue-next-rfc-doc/assets/css/0.styles.19b2238c.css" as="style"><link rel="preload" href="/vue-next-rfc-doc/assets/js/app.1ce19c03.js" as="script"><link rel="preload" href="/vue-next-rfc-doc/assets/js/2.3b75c94c.js" as="script"><link rel="preload" href="/vue-next-rfc-doc/assets/js/5.e9ef4f37.js" as="script"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/10.f0b17614.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/11.28097de8.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/12.15e6761d.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/3.e4b6b20e.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/4.f03b7f8e.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/6.8cb35972.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/7.0a02bdf2.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/8.25016343.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/9.62c8f8d6.js">
    <link rel="stylesheet" href="/vue-next-rfc-doc/assets/css/0.styles.19b2238c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-next-rfc-doc/" class="home-link router-link-active"><!----> <span class="site-name">Vue Composition API</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-next-rfc-doc/" class="nav-link">
  Composition API RFC
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/API.html" class="nav-link router-link-exact-active router-link-active">
  API Reference
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/RFCs/0001-new-slot-syntax.html" class="nav-link">
  RFCs
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-next-rfc-doc/" class="nav-link">
  Composition API RFC
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/API.html" class="nav-link router-link-exact-active router-link-active">
  API Reference
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/RFCs/0001-new-slot-syntax.html" class="nav-link">
  RFCs
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>API 文档</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-next-rfc-doc/API.html#setup" class="sidebar-link">setup</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#调用时机" class="sidebar-link">调用时机</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#模板的用法" class="sidebar-link">模板的用法</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#render-函数-jsx-的用法" class="sidebar-link">Render 函数 / JSX 的用法</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#参数" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#this-的用法" class="sidebar-link">this 的用法</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#类型定义" class="sidebar-link">类型定义</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#reactive" class="sidebar-link">reactive</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#类型定义-2" class="sidebar-link">类型定义</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#ref" class="sidebar-link">ref</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#在模板中使用" class="sidebar-link">在模板中使用</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#isref" class="sidebar-link">isRef</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#类型定义-3" class="sidebar-link">类型定义</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#torefs" class="sidebar-link">toRefs</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-next-rfc-doc/API.html#computed" class="sidebar-link">computed</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#类型定义-4" class="sidebar-link">类型定义</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#readonly" class="sidebar-link">readonly</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-next-rfc-doc/API.html#watch" class="sidebar-link">watch</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#基本用法" class="sidebar-link">基本用法</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#单个监听源" class="sidebar-link">单个监听源</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#多个监听源" class="sidebar-link">多个监听源</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#停止监听" class="sidebar-link">停止监听</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#清除副作用" class="sidebar-link">清除副作用</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#回调刷新时间" class="sidebar-link">回调刷新时间</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#延迟调用" class="sidebar-link">延迟调用</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#调试" class="sidebar-link">调试</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#类型定义-5" class="sidebar-link">类型定义</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#lifecycle-hooks" class="sidebar-link">Lifecycle Hooks</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#与-2-x-版本生命周期对应的-composition-api" class="sidebar-link">与 2.x 版本生命周期对应的 Composition API</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#新增的钩子函数" class="sidebar-link">新增的钩子函数</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#provide-inject" class="sidebar-link">provide &amp; inject</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#响应式注入" class="sidebar-link">响应式注入</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#类型定义-6" class="sidebar-link">类型定义</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#template-refs" class="sidebar-link">Template Refs</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#render-函数-jsx-的用法-2" class="sidebar-link">Render 函数 / JSX 的用法</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#在-v-for-中的用法" class="sidebar-link">在 v-for 中的用法</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#definecomponent" class="sidebar-link">defineComponent</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="api-文档"><a href="#api-文档" class="header-anchor">#</a> API 文档</h1> <h2 id="setup"><a href="#setup" class="header-anchor">#</a> <code>setup</code></h2> <p><code>setup</code> 函数是一个新的组件选项, 它是组件内部 Composition API 的入口函数.</p> <h3 id="调用时机"><a href="#调用时机" class="header-anchor">#</a> 调用时机</h3> <p>创建组件时, <code>setup</code> 会在初始 <code>props</code> 解析完成后立即调用. 它会在生命周期 <code>beforeCreate</code> 之前被调用.</p> <h3 id="模板的用法"><a href="#模板的用法" class="header-anchor">#</a> 模板的用法</h3> <p><code>setup</code> 返回的对象中的属性会被绑定到模板的上下文中:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ count }} {{ object.foo }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 暴露到模板中</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      count<span class="token punctuation">,</span>
      object
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>注意: 返回的 refs 在模板中会自动展开, 所以不需要使用 <code>.value</code></p> <h3 id="render-函数-jsx-的用法"><a href="#render-函数-jsx-的用法" class="header-anchor">#</a> Render 函数 / JSX 的用法</h3> <p><code>setup</code> 也可以返回一个 render 函数, 直接使用同一作用域中的响应式变量:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
      count<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
      object<span class="token punctuation">.</span>foo
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h3> <p>函数的第一个参数是解析好的 props</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> String
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意: 这个 <code>props</code> 对象是响应式的, 即当新的 <code>props</code> 传入时, 它会更新并触发 <code>watch</code> 的监听回调:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> String
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">name is: </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span> props<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>用户在开发时不可以修改 <code>props</code> 对象(如果你尝试修改控制台会有 warning 警告).</p> <p>第二个参数是 context 上下文对象, 它可以拿到 2.x 版本中挂载在 <code>this</code> 上的一些可选属性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context<span class="token punctuation">.</span>attrs
    context<span class="token punctuation">.</span>slots
    context<span class="token punctuation">.</span>emit
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>attrs</code> 和 <code>slots</code> 是组件实例内部对应值的代理, 即使更新了也能拿到最新的值, 不用担心解构拿到过时的值:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> <span class="token punctuation">{</span> attrs <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 以后某个时刻可能会调用的函数</span>
    <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 保证可以拿到最新的引用</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为什么把 <code>props</code> 单独放到第一个参数, 而不是放在 <code>context</code> 里面呢:
- <code>props</code> 相比其他属性更常用, 很多时候一个组件可能只会用到 <code>props</code>
- 把 <code>props</code> 单独拿出来可以更方便的声明它的类型, 这样不会搞混 <code>context</code> 其他属性的类型. 这样做还能不用改代码就在 <code>setup</code>, <code>render</code> 和 TSX 函数中直接使用.</p> <h3 id="this-的用法"><a href="#this-的用法" class="header-anchor">#</a> this 的用法</h3> <p>在 <code>setup()</code> 函数内用不了 <code>this</code>, 因为 <code>setup()</code> 会在 2.x 版本所有选项解析完成之前调用.
<code>this</code> (如果可用)会跟其他选项中的表现得完全不一样, <code>setup</code> 和其他选项一起用的时候, <code>this</code> 表现得不一样会让人很懵逼的.
另一个原因是, 新手经常会掉进这样一个陷阱:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span> <span class="token comment">// 不是你想得那个 `this`</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="类型定义"><a href="#类型定义" class="header-anchor">#</a> 类型定义</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Data</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">unknown</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">SetupContext</span> <span class="token punctuation">{</span>
  attrs<span class="token operator">:</span> Data
  slots<span class="token operator">:</span> Slots
  parent<span class="token operator">:</span> ComponentInstance <span class="token operator">|</span> <span class="token keyword">null</span>
  root<span class="token operator">:</span> ComponentInstance
  emit<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span>
  <span class="token parameter">props<span class="token operator">:</span> Data<span class="token punctuation">,</span>
  context<span class="token operator">:</span> SetupContext</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Data
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>要获得传递给 <code>setup()</code> 的参数的类型推断, 需要使用 <a href="#definecomponent">defineComponent</a></p></div> <h2 id="reactive"><a href="#reactive" class="header-anchor">#</a> <code>reactive</code></h2> <p>传入一个对象获取该对象得响应式代理, 相当于 2.x 版本的 <code>Vue.observable()</code> .</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>它会深度遍历并将所有属性转换成响应式的, 它会返回一个 ES2015 的 <code>Proxy</code> 对象.
建议只使用这个返回响应式代理对象, 不要对传入的原对象做任何操作.</p> <h3 id="类型定义-2"><a href="#类型定义-2" class="header-anchor">#</a> 类型定义</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> reactive<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>raw<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>
</code></pre></div><h2 id="ref"><a href="#ref" class="header-anchor">#</a> <code>ref</code></h2> <p>传入一个值作为内部值并返回一个响应式且可变的 ref 对象. 这个 ref 对象只有一个指向内部值的属性 <code>value</code> .</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>

count<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><p>如果传入的是一个对象作为内部值, 那么这个对象会先被 <code>reactive</code> 转换.</p> <h3 id="在模板中使用"><a href="#在模板中使用" class="header-anchor">#</a> 在模板中使用</h3> <p>在模板中使用一个 <code>setup()</code> 返回 <code>ref</code> 对象时, 它会自动展开, 不需要使用 <code>.value</code> 去访问它的内部值:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      count<span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li><p><strong>在响应式对象中使用</strong></p> <p>当一个 <code>ref</code> 对象作为响应式对象的属性被访问或修改时, 它也会自动展开:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 0</span>

state<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><p>注意, 如果将一个新的 ref 赋值给一个对象中的 ref 属性, 旧的会被替换掉:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> otherCount <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

state<span class="token punctuation">.</span>count <span class="token operator">=</span> otherCount
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div></li> <li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Ref</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>
</code></pre></div><p>有时候我们需要定义类型比较复杂的内部值, 我们可以利用泛型改写 ref 的默认类型:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> ref<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token comment">// foo 的类型是: Ref&lt;string | number&gt;</span>

foo<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">123</span> <span class="token comment">// 不会报错</span>
</code></pre></div></li></ul> <h2 id="isref"><a href="#isref" class="header-anchor">#</a> <code>isRef</code></h2> <p>检查一个值是否为 ref 对象. 当判断展开值时十分有用:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> unwrapped <span class="token operator">=</span> <span class="token function">isRef</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token operator">?</span> foo<span class="token punctuation">.</span>value <span class="token operator">:</span> foo
</code></pre></div><h3 id="类型定义-3"><a href="#类型定义-3" class="header-anchor">#</a> 类型定义</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">isRef</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token builtin">any</span></span><span class="token punctuation">)</span><span class="token operator">:</span> value <span class="token keyword">is</span> Ref<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span>
</code></pre></div><h2 id="torefs"><a href="#torefs" class="header-anchor">#</a> <code>toRefs</code></h2> <p>传入一个响应式对象, 返回所有属性被转换成 ref 对象的普通对象:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  bar<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> stateAsRefs <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token comment">/*
stateAsRefs 的类型如下:

{
  foo: Ref&lt;number&gt;,
  bar: Ref&lt;number&gt;
}
*/</span>

<span class="token comment">// ref 对象 跟 原属性 &quot;链接&quot;</span>
state<span class="token punctuation">.</span>foo<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stateAsRefs<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 2</span>

stateAsRefs<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre></div><p>Composition 函数返回一个响应式对象时, <code>toRefs</code> 十分有用, 可以保证解构返回对象时不会丢失响应性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useFeatureX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    bar<span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 省略 关于 state 的逻辑操作</span>

  <span class="token comment">// 返回时 转换成 refs</span>
  <span class="token keyword">return</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 解构时 不会丢失响应性</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFeatureX</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      foo<span class="token punctuation">,</span>
      bar
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="computed"><a href="#computed" class="header-anchor">#</a> <code>computed</code></h2> <p>传入一个 getter 函数, 根据 getter 函数返回一个只读的 ref 对象.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 2</span>

plusOne<span class="token punctuation">.</span>value<span class="token operator">++</span> <span class="token comment">// 会报错</span>
</code></pre></div><p>或者, 传入一个带有 <code>get</code> 和 <code>set</code> 方法的对象, 返回一个可写的 ref 对象.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token parameter">val</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> count<span class="token punctuation">.</span>value <span class="token operator">=</span> val <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

plusOne<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>
</code></pre></div><h3 id="类型定义-4"><a href="#类型定义-4" class="header-anchor">#</a> 类型定义</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 只读</span>
<span class="token keyword">function</span> computed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function-variable function">getter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span>Ref<span class="token operator">&lt;</span>Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;&gt;</span>

<span class="token comment">// 可写</span>
<span class="token keyword">function</span> computed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>options<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>
</code></pre></div><h2 id="readonly"><a href="#readonly" class="header-anchor">#</a> <code>readonly</code></h2> <p>传入一个对象(reactive, ref 或 普通对象), 返回一个只读的响应式 Proxy 对象:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> original <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> copy <span class="token operator">=</span> <span class="token function">readonly</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 响应式的监听 没有问题</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 改变 original 可以触发 copy 的监听回调</span>
original<span class="token punctuation">.</span>count<span class="token operator">++</span>

<span class="token comment">// 改变 copy 会失败并抛出一个警告</span>
copy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 警告!</span>
</code></pre></div><h2 id="watch"><a href="#watch" class="header-anchor">#</a> <code>watch</code></h2> <h3 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h3> <p>在下一个 tick (参考<a href="#%E5%9B%9E%E8%B0%83%E5%88%B7%E6%96%B0%E6%97%B6%E9%97%B4">回调刷新时间</a>) 执行一个回调函数, 并跟踪函数内的依赖变化, 当依赖发生变化时, 重新执行这个回调函数.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; 打印 0</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  count<span class="token punctuation">.</span>value<span class="token operator">++</span>
  <span class="token comment">// -&gt; 打印 1</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="单个监听源"><a href="#单个监听源" class="header-anchor">#</a> 单个监听源</h3> <p>有些时候我们想要:</p> <ul><li>触发回调的依赖更具体一些</li> <li>拿到依赖的之前状态的值</li></ul> <p>我们可以这样使用 <code>watch</code> :</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 监听一个 getter 函数</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> prevCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 或 直接监听一个 ref</span>
<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> prevCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="多个监听源"><a href="#多个监听源" class="header-anchor">#</a> 多个监听源</h3> <p>一个 <code>getter函数</code> 或 <code>ref</code> 可以被视为一个可监听的<code>源</code>, 使用数组就可以同时监听多个<code>源</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>fooRef<span class="token punctuation">,</span> barRef<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>prevFoo<span class="token punctuation">,</span> prevBar<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="停止监听"><a href="#停止监听" class="header-anchor">#</a> 停止监听</h3> <p>在<code>setup()</code>调用<code>watch</code>函数时, 监听者会关联到组件的生命周期, 在组件卸载时监听者会自动停止监听.</p> <p>其他情况下, 可以通过调用 <code>watch</code> 函数返回的 <code>stop</code> 函数手动停止监听:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> stop <span class="token operator">=</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 停止监听</span>
<span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="清除副作用"><a href="#清除副作用" class="header-anchor">#</a> 清除副作用</h3> <p>有些时候监听回调会执行一些异步的副作用, 当监听值发生改变时应该要阻止这些副作用.
所以监听者的回调函数可以接收一个参数, 这个参数是一个清理副作用的回调函数.
当以下情况发生时, 清理回调会触发:</p> <ul><li>监听回调即将重新调用时</li> <li>停止监听时</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 普通用例中 清理回调会作为第一个参数传入</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">onCleanup</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">performAsyncOperation</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token function">onCleanup</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// id 改变时 或 停止监听时</span>
    <span class="token comment">// 阻止之前的异步操作</span>
    token<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 有监听源的用例中 清理回调会作为第三个参数传入</span>
<span class="token function">watch</span><span class="token punctuation">(</span>idRef<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">id<span class="token punctuation">,</span> oldId<span class="token punctuation">,</span> onCleanup</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">performAsyncOperation</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
  <span class="token function">onCleanup</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// id 改变时 或 停止监听时</span>
    <span class="token comment">// 阻止之前的异步操作</span>
    token<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们用传入的注册函数来注册清理函数, 而不是像 React 的 <code>useEffect</code> 那样直接返回一个清理函数,
是因为 watcher 回调的返回值在异步场景下有特殊作用. 我们经常需要在 watcher 的回调中用 async function 来执行异步操作:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span>getId<span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们知道 async function 隐性地返回一个 Promise - 这样的情况下, 我们是无法返回一个需要被立刻注册的清理函数的.
除此之外, 回调返回的 Promise 还会被 Vue 用于内部的异步错误处理.</p> <h3 id="回调刷新时间"><a href="#回调刷新时间" class="header-anchor">#</a> 回调刷新时间</h3> <p>Vue 的响应式系统会缓存监听者的回调函数并异步地刷新它们, 这样可以避免同一个&quot;tick&quot;中多个状态改变导致的不必要的重复调用.
在内部, 组件的更新函数也是一个监听者回调. 当一个监听者回调进入队列时, 会在所有的组件 render 函数之后执行:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      count
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在上面这个例子中:</p> <ul><li>count 不是立即同步打印</li> <li>在组件挂载之后, 回调函数会优先调用</li> <li>在 <code>count</code> 改变时, 回调函数会在组件更新之后调用</li></ul> <p>经验法则: 当回调函数被调用时, 组件状态和 DOM 状态早已更新完毕.</p> <p>如果想同步或在组件更新之前调用回调函数, 我们可以给<code>watch</code>传入一个带有 flush 选项(默认为<code>'post'</code>)的 option :</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 同步调用</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  flush<span class="token operator">:</span> <span class="token string">'sync'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 在组件更新前调用</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  flush<span class="token operator">:</span> <span class="token string">'pre'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="延迟调用"><a href="#延迟调用" class="header-anchor">#</a> 延迟调用</h3> <p>在 2.x 版本中, <code>this.$watch</code> 和 <code>watch 选项</code> 的默认行为就是延迟调用的: 它会先执行一下 getter 函数, 但只在依赖改变时触发回调函数.
这样就会导致在监听回调和生命周期(如 <code>mounted</code>)中出现一些重复的逻辑. 3.0 版本提供的 <code>watch</code> 与之相反, 默认不会延迟调用, 可以避免一些重复逻辑.
如果想要延迟调用可以给<code>watch</code>传入一个带有 lazy 选项的 option :</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>foo<span class="token punctuation">,</span>
  <span class="token parameter">foo</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo is '</span> <span class="token operator">+</span> foo<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> lazy<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p>注意: lazy 只作用于 getter + callback 这种形式, 在只传入回调函数的形式中无效.</p> <h3 id="调试"><a href="#调试" class="header-anchor">#</a> 调试</h3> <p>给<code>watch</code>传入带有<code>onTrack</code>和<code>onTrigger</code>的 option 可以调试监听者的行为.</p> <ul><li>当 <code>reactive</code> 或 <code>ref</code> 被作为依赖跟踪时, <code>onTrack</code> 会被调用</li> <li>当依赖发生变化时, <code>onTrigger</code> 会被调用</li></ul> <p>这俩的回调函数可以接收一个包含依赖项信息的 debugger event 对象, 可以在回调函数中写一个 <code>debugger</code> 语句用 Chrome Devtools 手动调试:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">onTrigger</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">debugger</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>onTrack</code> 和 <code>onTrigger</code> 只在开发模式下有效.</p> <h3 id="类型定义-5"><a href="#类型定义-5" class="header-anchor">#</a> 类型定义</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token function-variable function">StopHandle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>

<span class="token keyword">type</span> WatcherSource<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span>

<span class="token keyword">type</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">WatcherSource</span><span class="token operator">&lt;</span>infer <span class="token constant">V</span><span class="token operator">&gt;</span> <span class="token operator">?</span> <span class="token constant">V</span> <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token function-variable function">InvalidationRegister</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">invalidate</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>

<span class="token keyword">interface</span> <span class="token class-name">DebuggerEvent</span> <span class="token punctuation">{</span>
  effect<span class="token operator">:</span> ReactiveEffect
  target<span class="token operator">:</span> <span class="token builtin">any</span>
  <span class="token keyword">type</span><span class="token operator">:</span> OperationTypes
  key<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">WatchOptions</span> <span class="token punctuation">{</span>
  lazy<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>
  flush<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'pre'</span> <span class="token operator">|</span> <span class="token string">'post'</span> <span class="token operator">|</span> <span class="token string">'sync'</span>
  deep<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>
  onTrack<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
  onTrigger<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token comment">// 基本用法</span>
<span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token function-variable function">effect</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">onInvalidate<span class="token operator">:</span> InvalidationRegister</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  options<span class="token operator">?</span><span class="token operator">:</span> WatchOptions
<span class="token punctuation">)</span><span class="token operator">:</span> StopHandle

<span class="token comment">// 单个监听源</span>
<span class="token keyword">function</span> watch<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  source<span class="token operator">:</span> WatcherSource<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">effect</span><span class="token operator">:</span> <span class="token punctuation">(</span>
    <span class="token parameter">value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>
    oldValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>
    onInvalidate<span class="token operator">:</span> InvalidationRegister</span>
  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  options<span class="token operator">?</span><span class="token operator">:</span> WatchOptions
<span class="token punctuation">)</span><span class="token operator">:</span> StopHandle

<span class="token comment">// 多个监听源</span>
<span class="token keyword">function</span> watch<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">WatcherSource</span><span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  sources<span class="token operator">:</span> <span class="token constant">T</span>
  <span class="token function-variable function">effect</span><span class="token operator">:</span> <span class="token punctuation">(</span>
    <span class="token parameter">values<span class="token operator">:</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    oldValues<span class="token operator">:</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    onInvalidate<span class="token operator">:</span> InvalidationRegister</span>
  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  options<span class="token operator">?</span> <span class="token operator">:</span> WatchOptions
<span class="token punctuation">)</span><span class="token operator">:</span> StopHandle
</code></pre></div><h2 id="lifecycle-hooks"><a href="#lifecycle-hooks" class="header-anchor">#</a> <code>Lifecycle Hooks</code></h2> <p>生命周期钩子可以通过导入<code>onXXX</code>函数直接注册:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted<span class="token punctuation">,</span> onUpdated<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'mounted!'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">onUpdated</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'updated!'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'unmounted!'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些生命周期注册函数只能在<code>setup()</code>中使用, 因为它们依赖于内部的全局状态来定位当前组件实例(正在调用<code>setup()</code>的组件实例),
不在当前组件下调用这些函数会抛出一个错误.</p> <h3 id="与-2-x-版本生命周期对应的-composition-api"><a href="#与-2-x-版本生命周期对应的-composition-api" class="header-anchor">#</a> 与 2.x 版本生命周期对应的 Composition API</h3> <ul><li><s><code>beforeCreate</code></s> -&gt; 使用 <code>setup()</code></li> <li><s><code>created</code></s>      -&gt; 使用 <code>setup()</code></li> <li><code>beforeMount</code>      -&gt; <code>onBeforeMount</code></li> <li><code>mounted</code>          -&gt; <code>onMounted</code></li> <li><code>beforeUpdate</code>     -&gt; <code>onBeforeUpdate</code></li> <li><code>updated</code>          -&gt; <code>onUpdated</code></li> <li><code>beforeDestroy</code>    -&gt; <code>onBeforeUnmount</code></li> <li><code>destroyed</code>        -&gt; <code>onUnmounted</code></li> <li><code>errorCaptured</code>    -&gt; <code>onErrorCaptured</code></li></ul> <h3 id="新增的钩子函数"><a href="#新增的钩子函数" class="header-anchor">#</a> 新增的钩子函数</h3> <p>除了 2.x 版本对应的钩子函数, 还提供了用于调试的钩子函数:</p> <ul><li><code>onRenderTracked</code></li> <li><code>onRenderTriggered</code></li></ul> <p>这俩钩子函数接收一个 <code>DebuggerEvent</code> 参数, 这个参数跟 <code>watch</code> 第二个参数 options 中的 <code>onTrack</code> 和 <code>onTrigger</code> 一样:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onRenderTriggered</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">debugger</span>
      <span class="token comment">// 检查哪个依赖性导致组件重新渲染</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="provide-inject"><a href="#provide-inject" class="header-anchor">#</a> <code>provide &amp; inject</code></h2> <p><code>provide</code> 和 <code>inject</code> 提供了依赖注入的功能, 和 2.x 版本的 <code>provide/inject</code> 选项类似.
这俩函数只能在祖孙(父子)组件的 <code>setup()</code> 中调用:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> provide<span class="token punctuation">,</span> inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> ThemeSymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> Ancestor <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">provide</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token string">'dark'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> Descendent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token string">'light'</span> <span class="token comment">/* 可选的缺省值 */</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      theme
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>inject</code> 可以第二个参数可以传入一个可选的缺省值, 如果不传并在上下文中没有找到 <code>provide</code> 提供的对应值, 这个函数会返回 <code>undefined</code>.</p> <h3 id="响应式注入"><a href="#响应式注入" class="header-anchor">#</a> 响应式注入</h3> <p>可以使用 ref 来保持注入值的响应式:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 提供者</span>
<span class="token keyword">const</span> themeRef <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'dark'</span><span class="token punctuation">)</span>
<span class="token function">provide</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> themeRef<span class="token punctuation">)</span>

<span class="token comment">// 使用者</span>
<span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">theme set to: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>theme<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如果注入的是一个响应式的值, 那么它的变化可以被监听到</p> <h3 id="类型定义-6"><a href="#类型定义-6" class="header-anchor">#</a> 类型定义</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">InjectionKey</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name">Symbol</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> provide<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>

<span class="token comment">// 不传 缺省值</span>
<span class="token keyword">function</span> inject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>
<span class="token comment">// 有传 缺省值</span>
<span class="token keyword">function</span> inject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">,</span> defaultValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>
</code></pre></div><p>Vue 提供一个继承了 <code>Symbol</code> 的泛型 <code>InjectionKey</code>, 可以在提供者和使用者之间保持类型一致:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> InjectionKey<span class="token punctuation">,</span> provide<span class="token punctuation">,</span> inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">provide</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token comment">// 类型不是 string 会报错</span>

<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// foo 的类型是: string | undefined</span>
</code></pre></div><p>如果第一个参数传入的是字符串或没有定义类型的符号, 就需要明确指定泛型的类型:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> inject<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token comment">// number | undefined</span>
</code></pre></div><h2 id="template-refs"><a href="#template-refs" class="header-anchor">#</a> <code>Template Refs</code></h2> <p>使用 Composition API 时, <code>reactive refs</code> 和 <code>template refs</code> 的概念是统一的.
我们需要在 <code>setup()</code> 中定义一个 ref 并返回给模板, 这样就可以通过 ref 来拿到一个 DOM 或 组件实例的引用了:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>root<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在渲染完成后, 这个 div DOM 会被赋值给 root ref 对象</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// &lt;div/&gt;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      root
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面将 <code>root</code> 暴露到 render 上下文, 并通过 <code>ref=&quot;root&quot;</code> 绑定到 div 上.
通过虚拟 DOM 的 patching 算法, 如果一个 VNode 节点上的 <code>ref</code> 匹配到 render 上下文中的 ref, 就会将 VNode 对应的 DOM 或组件实例赋值这个 ref.
这是在虚拟 DOM <code>mount / patch</code> 过程中执行的, 因此 <code>template refs</code> 只能在渲染完成后拿到引用值.</p> <p><code>template refs</code> 和其他 refs 一样: 是响应式的, 可以传给 Composition 函数, 也可以从函数中返回.</p> <h3 id="render-函数-jsx-的用法-2"><a href="#render-函数-jsx-的用法-2" class="header-anchor">#</a> Render 函数 / JSX 的用法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      ref<span class="token operator">:</span> root
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 使用 JSX</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span>root<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="在-v-for-中的用法"><a href="#在-v-for-中的用法" class="header-anchor">#</a> 在 v-for 中的用法</h3> <p>现在在 v-for 中 <code>template refs</code> 不会做特殊处理了, 而是需要使用 <code>函数属性的 ref (3.0 版本的新特性)</code> 来自定义处理:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
    <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>(item, i) in list<span class="token punctuation">&quot;</span></span>
    <span class="token attr-name">:ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>el =&gt; { divs[i] = el }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ item }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> reactive<span class="token punctuation">,</span> onBeforeUpdate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> divs <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment">// 确保在每次更新之前重置 ref</span>
    <span class="token function">onBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      divs<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">,</span>
      divs
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="definecomponent"><a href="#definecomponent" class="header-anchor">#</a> <code>defineComponent</code></h2> <p>该函数仅用于类型推断. 这个函数可以让 TypeScript 根据传入的组件对象正确推断出传给 <code>setup()</code> 的 props 的类型.
该函数不会做额外的操作, 传入组件对象并原样返回.</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span> String
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    props<span class="token punctuation">.</span>foo <span class="token comment">// &lt;- 类型为: string</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如果你的组件除了 <code>setup()</code> 没有其他选项, 可以直接传入一个函数:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token comment">// 直接为 props 参数定义类型</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  props<span class="token punctuation">.</span>foo
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>安装了 Vetur 插件的 VSCode 用户, 使用 SRCs 时导出组件会被隐式包装, 用户不需要手写以上代码.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vue-next-rfc-doc/assets/js/app.1ce19c03.js" defer></script><script src="/vue-next-rfc-doc/assets/js/2.3b75c94c.js" defer></script><script src="/vue-next-rfc-doc/assets/js/5.e9ef4f37.js" defer></script>
  </body>
</html>
