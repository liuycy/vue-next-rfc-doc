<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>API 文档 | Vue Composition API</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/vue-next-rfc-doc/logo.png">
    <link rel="manifest" href="/vue-next-rfc-doc/manifest.json">
    <link rel="apple-touch-icon" href="/vue-next-rfc-doc/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/vue-next-rfc-doc/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    <link rel="preload" href="/vue-next-rfc-doc/assets/css/0.styles.cf1b8447.css" as="style"><link rel="preload" href="/vue-next-rfc-doc/assets/js/app.22d7078e.js" as="script"><link rel="preload" href="/vue-next-rfc-doc/assets/js/2.f670e6b3.js" as="script"><link rel="preload" href="/vue-next-rfc-doc/assets/js/6.0e409d1f.js" as="script"><link rel="preload" href="/vue-next-rfc-doc/assets/js/3.fbfa2398.js" as="script"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/10.bf2829c4.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/11.085c641a.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/12.6ea47bef.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/13.a8ee82de.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/14.ecea75bd.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/15.50c7310e.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/16.597db85a.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/17.6c8e5b7e.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/18.739f5757.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/19.99699b5f.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/20.fe1e2bec.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/21.6b7b332c.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/22.92a733cb.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/23.109f017b.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/24.354577cb.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/25.92b58e50.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/26.1e19ed7d.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/27.c79d30b0.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/28.9aa8fbe3.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/29.6abdc0bf.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/30.620c1395.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/31.83d0a65a.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/32.de51063f.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/33.06c75933.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/34.aadd36d9.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/35.beec72bf.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/36.0d8e7d05.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/37.bbcb872d.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/38.7d1b6cd5.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/39.882a3c2b.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/4.12197861.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/40.a22bb1c9.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/5.dbe5f43d.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/7.a4926ea9.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/8.18ba420e.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/9.b09200d4.js">
    <link rel="stylesheet" href="/vue-next-rfc-doc/assets/css/0.styles.cf1b8447.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-next-rfc-doc/" class="home-link router-link-active"><!----> <span class="site-name">Vue Composition API</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-next-rfc-doc/" class="nav-link">
  Composition API RFC
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/API.html" class="nav-link router-link-exact-active router-link-active">
  API Reference
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/RFCs/0001-new-slot-syntax.html" class="nav-link">
  RFCs
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-next-rfc-doc/" class="nav-link">
  Composition API RFC
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/API.html" class="nav-link router-link-exact-active router-link-active">
  API Reference
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/RFCs/0001-new-slot-syntax.html" class="nav-link">
  RFCs
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>API 文档</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-next-rfc-doc/API.html#setup" class="sidebar-link">setup</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-next-rfc-doc/API.html#响应式-api" class="sidebar-link">响应式 API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#reactive" class="sidebar-link">reactive</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#ref" class="sidebar-link">ref</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#computed" class="sidebar-link">computed</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#readonly" class="sidebar-link">readonly</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#watcheffect" class="sidebar-link">watchEffect</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#watch" class="sidebar-link">watch</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-next-rfc-doc/API.html#依赖注入" class="sidebar-link">依赖注入</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-next-rfc-doc/API.html#模板-refs" class="sidebar-link">模板 Refs</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-next-rfc-doc/API.html#响应式工具函数" class="sidebar-link">响应式工具函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#unref" class="sidebar-link">unref</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#toref" class="sidebar-link">toRef</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#torefs" class="sidebar-link">toRefs</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#isref" class="sidebar-link">isRef</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#isproxy" class="sidebar-link">isProxy</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#isreactive" class="sidebar-link">isReactive</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#isreadonly" class="sidebar-link">isReadonly</a></li></ul></li><li><a href="/vue-next-rfc-doc/API.html#高级响应式-api" class="sidebar-link">高级响应式 API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#customref" class="sidebar-link">customRef</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#markraw" class="sidebar-link">markRaw</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#shallowreactive" class="sidebar-link">shallowReactive</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#shallowreadonly" class="sidebar-link">shallowReadonly</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#shallowref" class="sidebar-link">shallowRef</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/API.html#toraw" class="sidebar-link">toRaw</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="api-文档"><a href="#api-文档" class="header-anchor">#</a> API 文档</h1> <blockquote><p>原文: <a href="https://vue-composition-api-rfc.netlify.app/api.html" target="_blank" rel="noopener noreferrer">https://vue-composition-api-rfc.netlify.app/api.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="setup"><a href="#setup" class="header-anchor">#</a> <code>setup</code></h2> <p><code>setup</code> 函数是一个新的组件选项, 它是组件内部 Composition API 的入口函数.</p> <ul><li><p><strong>调用时机</strong></p> <p>创建组件时, <code>setup</code> 会在初始 <code>props</code> 解析完成后立即调用. 它会在生命周期 <code>beforeCreate</code> 之前被调用.</p></li> <li><p><strong>模板的用法</strong></p> <p><code>setup</code> 返回的对象中的属性会被绑定到模板的上下文中:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ count }} {{ object.foo }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 暴露到模板中</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      count<span class="token punctuation">,</span>
      object
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>注意: 返回的 refs 在模板中会自动展开, 所以不需要使用 <code>.value</code></p></li> <li><p><strong>Render 函数 / JSX 的用法</strong></p> <p><code>setup</code> 也可以返回一个 render 函数, 直接使用同一作用域中的响应式变量:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
      count<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
      object<span class="token punctuation">.</span>foo
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>参数</strong></p> <p>函数的第一个参数是解析好的 props</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> String
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意: 这个 <code>props</code> 对象是响应式的, 即当新的 <code>props</code> 传入时, 它会更新并触发 <code>watchEffect</code> 或 <code>watch</code> 的监听回调:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> String
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">name is: </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span> props<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是, <strong>千万不要</strong> 解构 <code>props</code> 对象, 这样会丢失响应性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> String
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> name <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">name is: </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token comment">// 将不会具有响应性 !</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>用户在开发时不可以修改 <code>props</code> 对象(如果你尝试修改控制台会有 warning 警告).</p> <p>第二个参数是 context 上下文对象, 它可以拿到 2.x 版本中挂载在 <code>this</code> 上的一些可选属性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context<span class="token punctuation">.</span>attrs
    context<span class="token punctuation">.</span>slots
    context<span class="token punctuation">.</span>emit
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>attrs</code> 和 <code>slots</code> 是组件实例内部对应值的代理, 即使更新了也能拿到最新的值, 不用担心解构拿到过时的值:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> <span class="token punctuation">{</span> attrs <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 以后某个时刻可能会调用的函数</span>
    <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 保证可以拿到最新的引用</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为什么把 <code>props</code> 单独放到第一个参数, 而不是放在 <code>context</code> 里面呢:</p> <ul><li><code>props</code> 相比其他属性更常用, 很多时候一个组件可能只会用到 <code>props</code></li> <li>把 <code>props</code> 单独拿出来可以更方便的声明它的类型, 这样不会搞混 <code>context</code> 其他属性的类型. 这样做还能不用改代码就在 <code>setup</code>, <code>render</code> 和 TSX 函数中直接使用.</li></ul></li> <li><p><strong>this 的用法</strong></p> <p>在 <code>setup()</code> 函数内用不了 <code>this</code>, 因为 <code>setup()</code> 会在 2.x 版本所有选项解析完成之前调用.
<code>this</code> (如果可用)会跟其他选项中的表现得完全不一样, <code>setup</code> 和其他选项一起用的时候, <code>this</code> 表现得不一样会让人很懵逼的.
另一个原因是, 新手经常会掉进这样一个陷阱:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span> <span class="token comment">// 不是你想得那个 `this`</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Data</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">unknown</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">SetupContext</span> <span class="token punctuation">{</span>
  attrs<span class="token operator">:</span> Data
  slots<span class="token operator">:</span> Slots
  emit<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span>
  <span class="token parameter">props<span class="token operator">:</span> Data<span class="token punctuation">,</span>
  context<span class="token operator">:</span> SetupContext</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Data
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>要获得传递给 <code>setup()</code> 的参数的类型推断, 需要使用 <a href="#definecomponent">defineComponent</a></p></div></li></ul> <h2 id="响应式-api"><a href="#响应式-api" class="header-anchor">#</a> 响应式 API</h2> <h3 id="reactive"><a href="#reactive" class="header-anchor">#</a> <code>reactive</code></h3> <p>传入一个对象获取该对象得响应式代理, 相当于 2.x 版本的 <code>Vue.observable()</code> .</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>它会深度遍历并将所有属性转换成响应式的, 它会返回一个 ES2015 的 <code>Proxy</code> 对象.
建议只使用这个返回响应式代理对象, 不要对传入的原对象做任何操作.</p> <ul><li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> reactive<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>raw<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>
</code></pre></div></li></ul> <h3 id="ref"><a href="#ref" class="header-anchor">#</a> <code>ref</code></h3> <p>传入一个值作为内部值并返回一个响应式且可变的 ref 对象. 这个 ref 对象只有一个指向内部值的属性 <code>value</code> .</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>

count<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><p>如果传入的是一个对象作为内部值, 那么这个对象会先被 <code>reactive</code> 转换.</p> <ul><li><p><strong>在模板中使用</strong></p> <p>在模板中使用一个 <code>setup()</code> 返回 <code>ref</code> 对象时, 它会自动展开, 不需要使用 <code>.value</code> 去访问它的内部值:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      count<span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p><strong>在响应式对象中使用</strong></p> <p>当一个 <code>ref</code> 对象作为响应式对象的属性被访问或修改时, 它也会自动展开:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 0</span>

state<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><p>注意, 如果将一个新的 ref 赋值给一个对象中的 ref 属性, 旧的会被替换掉:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> otherCount <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

state<span class="token punctuation">.</span>count <span class="token operator">=</span> otherCount
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><p>请注意, <code>ref</code> 只有嵌套在响应式<code>对象</code>中才会自动展开. 从 <code>数组</code> 或 原生集合类型像 <code>Map</code> 这些数据结构中访问的 <code>ref</code> 不会自动展开:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 这里就需要 .value 了</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>

<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 这里也需要 .value </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Ref</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>
</code></pre></div><p>有时候我们需要定义类型比较复杂的内部值, 我们可以利用泛型改写 ref 的默认类型:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> ref<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token comment">// foo 的类型是: Ref&lt;string | number&gt;</span>

foo<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">123</span> <span class="token comment">// 不会报错</span>
</code></pre></div></li></ul> <h3 id="computed"><a href="#computed" class="header-anchor">#</a> <code>computed</code></h3> <p>传入一个 getter 函数, 根据 getter 函数返回一个只读的 ref 对象.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 2</span>

plusOne<span class="token punctuation">.</span>value<span class="token operator">++</span> <span class="token comment">// 会报错</span>
</code></pre></div><p>或者, 传入一个带有 <code>get</code> 和 <code>set</code> 方法的对象, 返回一个可写的 ref 对象.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token parameter">val</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
    count<span class="token punctuation">.</span>value <span class="token operator">=</span> val <span class="token operator">-</span> <span class="token number">1</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

plusOne<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>
</code></pre></div><ul><li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 只读</span>
<span class="token keyword">function</span> computed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function-variable function">getter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span>Ref<span class="token operator">&lt;</span>Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;&gt;</span>

<span class="token comment">// 可写</span>
<span class="token keyword">function</span> computed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>options<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>
</code></pre></div></li></ul> <h3 id="readonly"><a href="#readonly" class="header-anchor">#</a> <code>readonly</code></h3> <p>传入一个对象(reactive 或 普通对象) 或者 ref, 返回一个只读的响应式 Proxy 对象. 这个只读代理对象的任何嵌套属性也都是只读的:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> original <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> copy <span class="token operator">=</span> <span class="token function">readonly</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 响应式的监听 没有问题</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 改变 original 可以触发 copy 的监听回调</span>
original<span class="token punctuation">.</span>count<span class="token operator">++</span>

<span class="token comment">// 改变 copy 会失败并抛出一个警告</span>
copy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// 警告!</span>
</code></pre></div><h3 id="watcheffect"><a href="#watcheffect" class="header-anchor">#</a> <code>watchEffect</code></h3> <p>立即执行一个回调函数, 并跟踪函数内的依赖变化, 当依赖发生变化时, 重新执行这个回调函数.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; 打印 0</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  count<span class="token punctuation">.</span>value<span class="token operator">++</span>
  <span class="token comment">// -&gt; 打印 1</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="停止监听"><a href="#停止监听" class="header-anchor">#</a> 停止监听</h4> <p>在 <code>setup()</code> 或 声明周期钩子函数中 调用 <code>watchEffect</code> 函数时, 监听者会关联到组件的生命周期, 在组件卸载时监听者会自动停止监听.</p> <p>其他情况下, 可以通过函数返回的 stop 函数明确地手动停止监听:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> stop <span class="token operator">=</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 停止监听</span>
<span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="清除副作用"><a href="#清除副作用" class="header-anchor">#</a> 清除副作用</h4> <p>有些时候监听回调会执行一些异步的副作用, 这些副作用需要在其失效时清除(即副作用完成之前状态就改变了).
所以监听者的回调函数可以接收一个 <code>onInvalidate</code> 函数入参, 可以用来注册清理副作用的回调函数.
当以下情况发生时, 清理回调会被触发:</p> <ul><li>监听回调即将重新调用时</li> <li>停止监听时 (如果在 <code>setup()</code> 或 生命周期钩子函数中 使用了 <code>watchEffect</code>, 则在卸载组件时)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 普通用例中 清理回调会作为第一个参数传入</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token parameter">onInvalidate</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">performAsyncOperation</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// id 改变时 或 停止监听时</span>
    <span class="token comment">// 取消之前的异步操作</span>
    token<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们用传入的注册函数来注册清理函数, 而不是像 React 的 <code>useEffect</code> 那样直接返回一个清理函数,
是因为 watcher 回调的返回值在异步场景下有特殊作用. 我们经常需要在 watcher 的回调中用 async function 来执行异步操作:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span>getId<span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们知道 async function 隐性地返回一个 Promise - 这样的情况下, 我们是无法返回一个需要被立刻注册的清理函数的.
除此之外, 回调返回的 Promise 还会被 Vue 用于内部的异步错误处理.</p> <h4 id="副作用回调刷新时间"><a href="#副作用回调刷新时间" class="header-anchor">#</a> 副作用回调刷新时间</h4> <p>Vue 的响应式系统会缓存监听者的回调函数并异步地刷新它们, 这样可以避免同一个&quot;tick&quot;中多个状态改变导致的不必要的重复调用.
在内部, 组件的更新函数也是一个监听者回调. 当一个监听者回调进入队列时, 会在所有的组件 render 函数之后执行:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      count
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在上面这个例子中:</p> <ul><li>count 会在初始运行时同步打印出来</li> <li>在 <code>count</code> 改变时, 回调函数会在组件<strong>更新之后</strong>调用</li></ul> <p>请注意, 初始运行是在组件挂载完成之前调用的, 如果你要在副作用回调中操作 DOM (或 模板 refs), 要把它放在 mounted 钩子函数内:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 访问 DOM 或 模板 refs</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如果想同步或在组件更新之前调用回调函数, 我们可以给<code>watchEffect</code>传入一个带有 flush 选项(默认为<code>'post'</code>)的 option :</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 同步调用</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span> 
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span>
    flush<span class="token operator">:</span> <span class="token string">'sync'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token comment">// 在组件更新前调用</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span> 
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span>
    flush<span class="token operator">:</span> <span class="token string">'pre'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><h4 id="watcher-调试"><a href="#watcher-调试" class="header-anchor">#</a> Watcher 调试</h4> <p>给<code>watchEffect</code>传入带有<code>onTrack</code>和<code>onTrigger</code>的 option 可以调试监听者的行为.</p> <ul><li>当 <code>reactive</code> 或 <code>ref</code> 被作为依赖跟踪时, <code>onTrack</code> 会被调用</li> <li>当依赖发生变化时, <code>onTrigger</code> 会被调用</li></ul> <p>这两个回调函数可以接收一个包含依赖项信息的 debugger event 对象, 建议在回调函数中写一个 <code>debugger</code> 语句用 Chrome Devtools 手动调试:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watchEffect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span> 
  <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token punctuation">{</span>
    <span class="token function">onTrigger</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">debugger</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p><code>onTrack</code> 和 <code>onTrigger</code> 只在开发模式下有效.</p> <ul><li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span>
  <span class="token function-variable function">effect</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">onInvalidate<span class="token operator">:</span> InvalidateCbRegistrator</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  options<span class="token operator">?</span><span class="token operator">:</span> WatchEffectOptions
<span class="token punctuation">)</span><span class="token operator">:</span> StopHandle

<span class="token keyword">interface</span> <span class="token class-name">WatchEffectOptions</span> <span class="token punctuation">{</span>
  flush<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'pre'</span> <span class="token operator">|</span> <span class="token string">'post'</span> <span class="token operator">|</span> <span class="token string">'sync'</span>
  onTrack<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
  onTrigger<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">DebuggerEvent</span> <span class="token punctuation">{</span>
  effect<span class="token operator">:</span> ReactiveEffect
  target<span class="token operator">:</span> <span class="token builtin">any</span>
  <span class="token keyword">type</span><span class="token operator">:</span> OperationTypes
  key<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token function-variable function">InvalidateCbRegistrator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">invalidate</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>

<span class="token keyword">type</span> <span class="token function-variable function">StopHandle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
</code></pre></div></li></ul> <h3 id="watch"><a href="#watch" class="header-anchor">#</a> <code>watch</code></h3> <p><code>watch</code> API 完全等价于 2.x 的 <code>this.$watch</code> (以及对应的 <code>watch</code> 的选项). <code>watch</code> 要求传入一个特定的监听源, 并在单独的回调函数中处理副作用. 默认情况下, 回调函数是惰性执行的 - 即只有在监听源发生改变时回调函数才会被调用.</p> <ul><li><p>与 <code>watchEffect</code> 对比, <code>watch</code> 可以:</p> <ul><li>惰性执行副作用回调</li> <li>更具体地控制触发监听回调的状态</li> <li>访问监听状态的之前值和当前值</li></ul></li> <li><p><strong>单个监听源</strong></p> <p>一个监听源可以是一个返回值的 getter 函数, 也可以直接是一个 ref:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 监听一个 getter 函数</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span> 
  <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> prevCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token comment">// 或 直接监听一个 ref</span>
<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> prevCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>多个监听源</strong></p> <p>一个 <code>getter函数</code> 或 <code>ref</code> 可以被视为一个可监听的<code>源</code>, 使用数组就可以同时监听多个<code>源</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>fooRef<span class="token punctuation">,</span> barRef<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>prevFoo<span class="token punctuation">,</span> prevBar<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>与 <code>watchEffect</code> 共享的行为</strong></p></li></ul> <p><code>watch</code> 和 <code>watchEffect</code> 在<a href="#%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC">停止监听</a>, <a href="#%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8">清除副作用</a>(<code>onInvalidate</code>回调入参会作为第三个参数传入), <a href="#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%9B%9E%E8%B0%83%E5%88%B7%E6%96%B0%E6%97%B6%E9%97%B4">副作用回调刷新时间</a> 和 <a href="#watcher-%E8%B0%83%E8%AF%95">调试</a> 等方面行为一致.</p> <ul><li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 单个监听源</span>
<span class="token keyword">function</span> watch<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  source<span class="token operator">:</span> WatcherSource<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>
    <span class="token parameter">value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>
    oldValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>
    onInvalidate<span class="token operator">:</span> InvalidateCbRegistrator</span>
  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  options<span class="token operator">?</span><span class="token operator">:</span> WatchOptions
<span class="token punctuation">)</span><span class="token operator">:</span> StopHandle

<span class="token comment">// 多个监听源</span>
<span class="token keyword">function</span> watch<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">WatcherSource</span><span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  sources<span class="token operator">:</span> <span class="token constant">T</span>
  <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>
    <span class="token parameter">values<span class="token operator">:</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    oldValues<span class="token operator">:</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    onInvalidate<span class="token operator">:</span> InvalidateCbRegistrator</span>
  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  options<span class="token operator">?</span> <span class="token operator">:</span> WatchOptions
<span class="token punctuation">)</span><span class="token operator">:</span> StopHandle

<span class="token keyword">type</span> WatcherSource<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span>

<span class="token keyword">type</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">WatcherSource</span><span class="token operator">&lt;</span>infer <span class="token constant">V</span><span class="token operator">&gt;</span> <span class="token operator">?</span> <span class="token constant">V</span> <span class="token operator">:</span> <span class="token builtin">never</span>
<span class="token punctuation">}</span>

<span class="token comment">// 可以查看 `watchEffect` 类型定义 中 其他共享 options 的定义</span>
<span class="token keyword">interface</span> <span class="token class-name">WatchOptions</span> <span class="token keyword">extends</span> <span class="token class-name">WatchEffectOptions</span> <span class="token punctuation">{</span>
  immediate<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token comment">// 默认: false</span>
  deep<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>生命周期钩子可以通过导入<code>onXXX</code>函数直接注册:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted<span class="token punctuation">,</span> onUpdated<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'mounted!'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">onUpdated</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'updated!'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'unmounted!'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些生命周期注册函数只能在<code>setup()</code>中使用, 因为它们依赖于内部的全局状态来定位当前组件实例(正在调用<code>setup()</code>的组件实例),
不在当前组件下调用这些函数会抛出一个错误.</p> <p>组件实例上下文也是在生命周期钩子执行时同步设置的, 因此当组件卸载时, 在生命周期钩子内同步创建的监听者和计算属性也会被自动销毁</p> <ul><li><p><strong>与 2.x 版本生命周期对应的 Composition API</strong></p> <ul><li><s><code>beforeCreate</code></s> -&gt; 使用 <code>setup()</code></li> <li><s><code>created</code></s>      -&gt; 使用 <code>setup()</code></li> <li><code>beforeMount</code>      -&gt; <code>onBeforeMount</code></li> <li><code>mounted</code>          -&gt; <code>onMounted</code></li> <li><code>beforeUpdate</code>     -&gt; <code>onBeforeUpdate</code></li> <li><code>updated</code>          -&gt; <code>onUpdated</code></li> <li><code>beforeDestroy</code>    -&gt; <code>onBeforeUnmount</code></li> <li><code>destroyed</code>        -&gt; <code>onUnmounted</code></li> <li><code>errorCaptured</code>    -&gt; <code>onErrorCaptured</code></li></ul></li> <li><p><strong>新增的钩子函数</strong></p> <p>除了 2.x 版本对应的钩子函数, 还提供了用于调试的钩子函数:</p> <ul><li><code>onRenderTracked</code></li> <li><code>onRenderTriggered</code></li></ul> <p>这俩钩子函数接收一个 <code>DebuggerEvent</code> 参数, 这个参数跟 <code>watchEffect</code> 第二个参数 options 中的 <code>onTrack</code> 和 <code>onTrigger</code> 一样:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onRenderTriggered</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">debugger</span>
      <span class="token comment">// 检查哪个依赖性导致组件重新渲染</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="依赖注入"><a href="#依赖注入" class="header-anchor">#</a> 依赖注入</h2> <p><code>provide</code> 和 <code>inject</code> 提供了依赖注入的功能, 和 2.x 版本的 <code>provide/inject</code> 选项类似.
这俩函数只能在祖孙(父子)组件的 <code>setup()</code> 中调用:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> provide<span class="token punctuation">,</span> inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> ThemeSymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> Ancestor <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">provide</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token string">'dark'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> Descendent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token string">'light'</span> <span class="token comment">/* 可选的缺省值 */</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      theme
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>inject</code> 可以第二个参数可以传入一个可选的缺省值, 如果不传并在上下文中没有找到 <code>provide</code> 提供的对应值, 这个函数会返回 <code>undefined</code>.</p> <ul><li><p><strong>响应式注入</strong></p> <p>可以使用 ref 来保持注入值的响应式:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 提供者</span>
<span class="token keyword">const</span> themeRef <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'dark'</span><span class="token punctuation">)</span>
<span class="token function">provide</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> themeRef<span class="token punctuation">)</span>

<span class="token comment">// 使用者</span>
<span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">theme set to: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>theme<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如果注入的是一个响应式的值, 那么它的变化可以被监听到</p></li> <li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">InjectionKey</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name">Symbol</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> provide<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>

<span class="token comment">// 不传 缺省值</span>
<span class="token keyword">function</span> inject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>
<span class="token comment">// 有传 缺省值</span>
<span class="token keyword">function</span> inject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">,</span> defaultValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>
</code></pre></div><p>Vue 提供一个继承了 <code>Symbol</code> 的泛型 <code>InjectionKey</code>, 可以在提供者和使用者之间保持类型一致:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> InjectionKey<span class="token punctuation">,</span> provide<span class="token punctuation">,</span> inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">provide</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token comment">// 类型不是 string 会报错</span>

<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// foo 的类型是: string | undefined</span>
</code></pre></div><p>如果第一个参数传入的是字符串或没有定义类型的符号, 就需要明确指定泛型的类型:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> inject<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token comment">// number | undefined</span>
</code></pre></div></li></ul> <h2 id="模板-refs"><a href="#模板-refs" class="header-anchor">#</a> 模板 Refs</h2> <p>使用 Composition API 时, <em>reactive refs</em> 和 <em>template refs</em> 的概念是统一的.
我们需要在 <code>setup()</code> 中定义一个 ref 并返回给模板, 这样就可以通过 ref 来拿到一个 DOM 或 组件实例的引用了:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>root<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在渲染完成后, 这个 div DOM 会被赋值给 root ref 对象</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// &lt;div/&gt;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      root
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面将 <code>root</code> 暴露到 render 上下文, 并通过 <code>ref=&quot;root&quot;</code> 绑定到 div 上.
通过虚拟 DOM 的 patching 算法, 如果一个 VNode 节点上的 <code>ref</code> 匹配到 render 上下文中的 ref, 就会将 VNode 对应的 DOM 或组件实例赋值这个 ref.
这是在虚拟 DOM <code>mount / patch</code> 过程中执行的, 因此 <code>template refs</code> 只能在渲染完成后拿到引用值.</p> <p><code>template refs</code> 和其他 refs 一样: 是响应式的, 可以传给 Composition 函数, 也可以从函数中返回.</p> <ul><li><p><strong>Render 函数 / JSX 的用法</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      ref<span class="token operator">:</span> root
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 使用 JSX</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span>root<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>在 <code>v-for</code> 中的用法</strong></p> <p>现在在 v-for 中 <code>template refs</code> 不会做特殊处理了, 而是需要使用 <code>函数属性的 ref (3.0 版本的新特性)</code> 来自定义处理:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
    <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>(item, i) in list<span class="token punctuation">&quot;</span></span>
    <span class="token attr-name">:ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>el =&gt; { divs[i] = el }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ item }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> reactive<span class="token punctuation">,</span> onBeforeUpdate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> divs <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment">// 确保在每次更新之前重置 ref</span>
    <span class="token function">onBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      divs<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">,</span>
      divs
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ul> <h2 id="响应式工具函数"><a href="#响应式工具函数" class="header-anchor">#</a> 响应式工具函数</h2> <h3 id="unref"><a href="#unref" class="header-anchor">#</a> <code>unref</code></h3> <p>如果传入参数是 ref 这个函数会返回内部值, 否则就返回传入值. 这是一个 <code>val = isRef(val) ? val.value : val</code> 的语法糖.</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">useFoo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> Ref<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> unwrapped <span class="token operator">=</span> <span class="token function">unref</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// 获取到的 unwrapped 类型是 number</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="toref"><a href="#toref" class="header-anchor">#</a> <code>toRef</code></h3> <p><code>toRef</code> 可以为响应式对象的属性创建 ref, 并保留原属性的响应式.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  bar<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> fooRef <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span>

fooRef<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 2</span>

state<span class="token punctuation">.</span>foo<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fooRef<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre></div><p>当你想给一个 Composition 函数传入 ref 时, 你会发现 <code>toRef</code> 非常有用:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">useSomeFeature</span><span class="token punctuation">(</span><span class="token function">toRef</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="torefs"><a href="#torefs" class="header-anchor">#</a> <code>toRefs</code></h3> <p>传入一个响应式对象, 返回所有属性被转换成 ref 对象的普通对象:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  bar<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> stateAsRefs <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token comment">/*
stateAsRefs 的类型如下:

{
  foo: Ref&lt;number&gt;,
  bar: Ref&lt;number&gt;
}
*/</span>

<span class="token comment">// ref 对象 跟 原属性 &quot;链接&quot;</span>
state<span class="token punctuation">.</span>foo<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stateAsRefs<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 2</span>

stateAsRefs<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre></div><p>Composition 函数返回一个响应式对象时, <code>toRefs</code> 十分有用, 可以保证解构返回对象时不会丢失响应性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useFeatureX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    bar<span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 省略 关于 state 的逻辑操作</span>

  <span class="token comment">// 返回时 转换成 refs</span>
  <span class="token keyword">return</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 解构时 不会丢失响应性</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFeatureX</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      foo<span class="token punctuation">,</span>
      bar
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="isref"><a href="#isref" class="header-anchor">#</a> <code>isRef</code></h3> <p>检查一个值是否为 ref 对象. 当判断展开值时十分有用.</p> <h3 id="isproxy"><a href="#isproxy" class="header-anchor">#</a> <code>isProxy</code></h3> <p>检查一个对象是否为 <code>reactive</code> 或 <code>readonly</code> 创建的代理对象.</p> <h3 id="isreactive"><a href="#isreactive" class="header-anchor">#</a> <code>isReactive</code></h3> <p>检查一个对象是否为 <code>reactive</code> 创建的响应式对象.</p> <p>如果这个对象是被 <code>readonly</code> 包装的 <code>reactive</code> 创建的对象, 也会返回 <code>true</code>.</p> <h3 id="isreadonly"><a href="#isreadonly" class="header-anchor">#</a> <code>isReadonly</code></h3> <p>检查一个对象是否为 <code>readonly</code> 创建的只读代理对象.</p> <h2 id="高级响应式-api"><a href="#高级响应式-api" class="header-anchor">#</a> 高级响应式 API</h2> <h3 id="customref"><a href="#customref" class="header-anchor">#</a> <code>customRef</code></h3> <p>创建一个自定义的 ref, 可以显式地控制它的依赖跟踪和更新时机. 需要传入一个工厂函数. 这个函数接收 <code>track</code> 和 <code>trigger</code> 两个回调, 并返回一个设置了 <code>get</code> 和 <code>set</code> 的对象.</p> <ul><li><p>用一个自定义 ref 来实现 <code>v-model</code> 的防抖功能:</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useDebouncedRef</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> delay <span class="token operator">=</span> <span class="token number">200</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout
  <span class="token keyword">return</span> <span class="token function">customRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">track<span class="token punctuation">,</span> trigger</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">track</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> value
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token keyword">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          value <span class="token operator">=</span> newValue
          <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      text<span class="token operator">:</span> <span class="token function">useDebouncedRef</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>类型定义</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> customRef<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>factory<span class="token operator">:</span> CustomRefFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>
<span class="token keyword">type</span> CustomRefFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
  <span class="token function-variable function">track</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  <span class="token function-variable function">trigger</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="markraw"><a href="#markraw" class="header-anchor">#</a> <code>markRaw</code></h3> <p>标记一个对象, 让这个对象不能被转换为代理对象. 返回值是它本身.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">markRaw</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isReactive</span><span class="token punctuation">(</span><span class="token function">reactive</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>

<span class="token comment">// 嵌套到其他响应式对象后, 也不会转换</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isReactive</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p><code>markRaw</code> 和下面的 shallowXXX API 可以让你在状态树中插入原始的, 非代理的对象, 使其不受 reactive / readonly 的深层转换影响. 可以在以下情况下使用:</p> <ul><li><p>有些值不能弄成响应式的, 例如第三方的复杂类的实例, 或 Vue 组件对象</p></li> <li><p>使用不可变数据源渲染大型列表时, 跳过转换可以提升性能</p></li> <li><p>这些是高级 API, 因为原始对象只有在第一层才能不受转换影响, 如果你将一个没有被标记的内嵌对象, 插入一个响应式对象再访问, 你获取到的还是代理对象. 这会导致<strong>相等障碍(identity hazards)</strong> - 例如: 对同一个对象的原始对象和代理对象进行比较运算:</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">markRaw</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nested<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 虽然 `foo` 被标记为原始对象, 但 foo.nested 不是</span>
  nested<span class="token operator">:</span> foo<span class="token punctuation">.</span>nested
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>nested <span class="token operator">===</span> bar<span class="token punctuation">.</span>nested<span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>相等障碍通常很少见. 不过要想避免这种问题充分利用这些 API 需要对响应式系统的工作原理有深入的了解.</p></div> <h3 id="shallowreactive"><a href="#shallowreactive" class="header-anchor">#</a> <code>shallowReactive</code></h3> <p>创建一个能跟踪自身属性变化的响应式的代理, 但不对内嵌对象进行深度响应式转换 (即暴露原始对象).</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  nested<span class="token operator">:</span> <span class="token punctuation">{</span>
    bar<span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 修改 state 自身的属性, 是响应式的</span>
state<span class="token punctuation">.</span>foo<span class="token operator">++</span>
<span class="token comment">// 当其内嵌对象不是响应式的</span>
<span class="token function">isReactive</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>nested<span class="token punctuation">)</span> <span class="token comment">// false</span>
state<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>bar<span class="token operator">++</span> <span class="token comment">// 非响应式的</span>
</code></pre></div><h3 id="shallowreadonly"><a href="#shallowreadonly" class="header-anchor">#</a> <code>shallowReadonly</code></h3> <p>创建一个只有自身属性只读的代理对象, 但不对内嵌对象进行深度只读转换 (即暴露原始对象).</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">shallowReadonly</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  nested<span class="token operator">:</span> <span class="token punctuation">{</span>
    bar<span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 修改 state 自身的属性会失败</span>
state<span class="token punctuation">.</span>foo<span class="token operator">++</span>
<span class="token comment">// 但可以修改内嵌对象</span>
<span class="token function">isReadonly</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>nested<span class="token punctuation">)</span> <span class="token comment">// false</span>
state<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>bar<span class="token operator">++</span> <span class="token comment">// 成功</span>
</code></pre></div><h3 id="shallowref"><a href="#shallowref" class="header-anchor">#</a> <code>shallowRef</code></h3> <p>创建一个能够跟踪 <code>.value</code> 变化但却使其 value 非响应式的 ref.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">shallowRef</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 修改 ref 的 value 是可响应的</span>
foo<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 不过其 value 没有被转换.</span>
<span class="token function">isReactive</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><h3 id="toraw"><a href="#toraw" class="header-anchor">#</a> <code>toRaw</code></h3> <p>返回 <code>reactive</code> 或 <code>readonly</code> 代理对象的原始对象. 这是一种应急用法, 可以在读取时不触发代理对象的访问/跟踪, 修改时不触发变更. <strong>不建议</strong>永久持有转换后的原始对象. 请谨慎使用.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> reactiveFoo <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toRaw</span><span class="token punctuation">(</span>reactiveFoo<span class="token punctuation">)</span> <span class="token operator">===</span> foo<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/vue-next-rfc-doc/assets/js/app.22d7078e.js" defer></script><script src="/vue-next-rfc-doc/assets/js/2.f670e6b3.js" defer></script><script src="/vue-next-rfc-doc/assets/js/6.0e409d1f.js" defer></script><script src="/vue-next-rfc-doc/assets/js/3.fbfa2398.js" defer></script>
  </body>
</html>
