<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>9. 全局 API 更改 | Vue Composition API</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/vue-next-rfc-doc/logo.png">
  <link rel="manifest" href="/vue-next-rfc-doc/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/vue-next-rfc-doc/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/vue-next-rfc-doc/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/vue-next-rfc-doc/assets/css/0.styles.016c9516.css" as="style"><link rel="preload" href="/vue-next-rfc-doc/assets/js/app.be83df36.js" as="script"><link rel="preload" href="/vue-next-rfc-doc/assets/js/2.fc158681.js" as="script"><link rel="preload" href="/vue-next-rfc-doc/assets/js/15.f2dd0c1d.js" as="script"><link rel="preload" href="/vue-next-rfc-doc/assets/js/3.2d17116a.js" as="script"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/10.c19953b2.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/11.00a5e7a8.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/12.ddc7c11c.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/13.15e26c2a.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/14.8ba2eed3.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/16.f3f3a152.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/17.5e5ae9d4.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/18.91e15308.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/19.fb75ffa2.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/20.fd94ba45.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/21.f4f3c0a9.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/22.3f54d893.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/23.cf69c11f.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/24.066a60e6.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/25.33d4dad9.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/26.18dbb40b.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/27.0b0ebbad.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/28.db4bb01e.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/29.011d7e6a.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/4.11373d65.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/5.fe4a2776.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/6.09c32356.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/7.37a152b0.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/8.a75ea55c.js"><link rel="prefetch" href="/vue-next-rfc-doc/assets/js/9.d1be0c45.js">
    <link rel="stylesheet" href="/vue-next-rfc-doc/assets/css/0.styles.016c9516.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-next-rfc-doc/" class="home-link router-link-active"><!----> <span class="site-name">Vue Composition API</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-next-rfc-doc/" class="nav-link">
  Composition API RFC
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/API.html" class="nav-link">
  API Reference
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/RFCs/0001-new-slot-syntax.html" class="nav-link">
  RFCs
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-next-rfc-doc/" class="nav-link">
  Composition API RFC
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/API.html" class="nav-link">
  API Reference
</a></div><div class="nav-item"><a href="/vue-next-rfc-doc/RFCs/0001-new-slot-syntax.html" class="nav-link">
  RFCs
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>RFCs</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-next-rfc-doc/RFCs/0001-new-slot-syntax.html" class="sidebar-link">1. 新的插槽语法</a></li><li><a href="/vue-next-rfc-doc/RFCs/0002-slot-syntax-shorthand.html" class="sidebar-link">2. 插槽语法缩写</a></li><li><a href="/vue-next-rfc-doc/RFCs/0003-dynamic-directive-arguments.html" class="sidebar-link">3. 动态指令参数</a></li><li><a href="/vue-next-rfc-doc/RFCs/0004-global-api-treeshaking.html" class="sidebar-link">4. 全局 API treeshaking</a></li><li><a href="/vue-next-rfc-doc/RFCs/0005-replace-v-bind-sync-with-v-model-argument.html" class="sidebar-link">5. 用 v-model 取代 v-bind.sync</a></li><li><a href="/vue-next-rfc-doc/RFCs/0006-slots-unification.html" class="sidebar-link">6. 统一插槽</a></li><li><a href="/vue-next-rfc-doc/RFCs/0007-functional-async-api-change.html" class="sidebar-link">7. 函数式组件和异步组件 API 更改</a></li><li><a href="/vue-next-rfc-doc/RFCs/0008-render-function-api-change.html" class="sidebar-link">8. render 函数 API 更改</a></li><li><a href="/vue-next-rfc-doc/RFCs/0009-global-api-change.html" class="active sidebar-link">9. 全局 API 更改</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/RFCs/0009-global-api-change.html#概要" class="sidebar-link">概要</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/RFCs/0009-global-api-change.html#基本用例" class="sidebar-link">基本用例</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/RFCs/0009-global-api-change.html#动机" class="sidebar-link">动机</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/RFCs/0009-global-api-change.html#设计细节" class="sidebar-link">设计细节</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/RFCs/0009-global-api-change.html#缺点" class="sidebar-link">缺点</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/RFCs/0009-global-api-change.html#备选方案" class="sidebar-link">备选方案</a></li><li class="sidebar-sub-header"><a href="/vue-next-rfc-doc/RFCs/0009-global-api-change.html#升级策略" class="sidebar-link">升级策略</a></li></ul></li><li><a href="/vue-next-rfc-doc/RFCs/0010-optional-props-declaration.html" class="sidebar-link">10. 可选的 props 声明</a></li><li><a href="/vue-next-rfc-doc/RFCs/0011-v-model-api-change.html" class="sidebar-link">11. v-model API 更改</a></li><li><a href="/vue-next-rfc-doc/RFCs/0012-custom-directive-api-change.html" class="sidebar-link">12. 自定义指令 API 更改</a></li><li><a href="/vue-next-rfc-doc/RFCs/0014-drop-keycode-support.html" class="sidebar-link">14. 废弃 keycode</a></li><li><a href="/vue-next-rfc-doc/RFCs/0015-remove-filters.html" class="sidebar-link">15. 移除 filters</a></li><li><a href="/vue-next-rfc-doc/RFCs/0016-remove-inline-templates.html" class="sidebar-link">16. 移除行内模板</a></li><li><a href="/vue-next-rfc-doc/RFCs/0017-transition-as-root.html" class="sidebar-link">17.  作为根节点时</a></li><li><a href="/vue-next-rfc-doc/RFCs/0019-remove-data-object-declaration.html" class="sidebar-link">19. 移除 data 对象形式声明</a></li><li><a href="/vue-next-rfc-doc/RFCs/0020-events-api-change.html" class="sidebar-link">20. 事件 API 更改</a></li><li><a href="/vue-next-rfc-doc/RFCs/0021-router-link-scoped-slot.html" class="sidebar-link">21. router-link 作用域插槽</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_9-全局-api-更改"><a href="#_9-全局-api-更改" class="header-anchor">#</a> 9. 全局 API 更改</h1> <blockquote><p>原文: <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0009-global-api-change.md" target="_blank" rel="noopener noreferrer">https://github.com/vuejs/rfcs/blob/master/active-rfcs/0009-global-api-change.md<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <ul><li>开始日期: 2019-04-08</li> <li>目标版本: 3.x</li> <li>参考 Issues: N/A</li> <li>实现 PR: N/A</li></ul> <h2 id="概要"><a href="#概要" class="header-anchor">#</a> 概要</h2> <p>重新设置 app 的 引导程序 和 API.</p> <ul><li>能够改变 Vue 行为的全局 API 现在移到通过 <code>createApp</code> 方法创建的 app 实例上了, 并且只能影响到这个 app 实例的行为了.</li> <li>不会改变 Vue 行为的全局 API (如: <code>nextTick</code> 和 <a href="https://github.com/vuejs/rfcs/pull/22" target="_blank" rel="noopener noreferrer">Advanced Reactivity API<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提到的 API) 现在通过命名导出了, 详见<a href="/vue-next-rfc-doc/RFCs/0004-global-api-treeshaking.html">全局 API treeshaking</a>.</li></ul> <h2 id="基本用例"><a href="#基本用例" class="header-anchor">#</a> 基本用例</h2> <h3 id="以前"><a href="#以前" class="header-anchor">#</a> 以前</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>

Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>ignoredElements <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token regex">/^app-/</span><span class="token punctuation">]</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>

<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">customProperty</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="以后"><a href="#以后" class="header-anchor">#</a> 以后</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>

app<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">isCustomElement</span> <span class="token operator">=</span> <span class="token parameter">tag</span> <span class="token operator">=&gt;</span> tag<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'app-'</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>

app<span class="token punctuation">.</span>config<span class="token punctuation">.</span>globalProperties<span class="token punctuation">.</span><span class="token function-variable function">customProperty</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span>App<span class="token punctuation">,</span> <span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="动机"><a href="#动机" class="header-anchor">#</a> 动机</h2> <p>Vue 当前的一些全局 API 会永久的改变全局状态, 这导致了一些问题:</p> <ul><li><p>在测试过程中, 全局配置会很容易污染其他测试用例, 用户需要每次都要在测试前保存全局配置并在测试后重置 (如: 重置 <code>Vue.config.errorHandler</code>).
一些 API (像 <code>Vue.use</code> 和 <code>Vue.mixin</code>) 甚至都无法还原成原样, 这会让插件测试变得相当棘手.</p> <ul><li><code>vue-test-utils</code> 必须实现一个特殊的 API <code>createLocalVue</code> 来解决这个问题</li></ul></li> <li><p>这也很难让同一个页面上的多个 &quot;app&quot; 使用不同的全局配置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这会影响到所有的根实例</span>
Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> app1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> el<span class="token operator">:</span> <span class="token string">'#app-1'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> app2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> el<span class="token operator">:</span> <span class="token string">'#app-2'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <h2 id="设计细节"><a href="#设计细节" class="header-anchor">#</a> 设计细节</h2> <p>理论上讲, Vue 2 没有真正的 &quot;app&quot; 概念, 我们定义的所谓 app 只是一个通过 <code>new Vue()</code> 创建的 Vue 根实例. 用同一个 Vue 创建的所有根实例会共享相同的全局配置.</p> <p>在此提案中, 我们引入了一个新的全局 API <code>createApp</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">/* 定义根组件 */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>调用 <code>createApp</code> 会返回一个 <strong>app 实例</strong>, 每一个 app 实例会提供一个 app 上下文.
app 实例上的组件树会共享一个 app 上下文, 这个上下文会提供之前 2.x 的&quot;全局&quot;配置.</p> <h3 id="全局-api-映射"><a href="#全局-api-映射" class="header-anchor">#</a> 全局 API 映射</h3> <p>app 实例上暴露了当前全局 API 的子集, 任何可以改变 Vue 行为的全局 API 的最佳实践都适用于现在的 app 实例, 包括:</p> <ul><li>全局配置
<ul><li><code>Vue.config</code> -&gt; <code>app.config</code> <ul><li><code>config.productionTip</code>: 移除. (<a href="#%E7%A7%BB%E9%99%A4-configproductiontip">更多细节</a>)</li> <li><code>config.ignoredElements</code> -&gt; <code>config.isCustomElement</code>. (<a href="#configignoredelements---configiscustomelement">更多细节</a>)</li> <li><code>config.keyCodes</code>: 移除. (<a href="/vue-next-rfc-doc/RFCs/0014-drop-keycode-support.html">更多细节</a>)</li> <li><code>config.optionMergeStrategies</code>: <a href="#configoptionmergestrategies-%E8%A1%8C%E4%B8%BA%E5%8F%98%E6%9B%B4">关于该调整的更多细节</a></li></ul></li></ul></li> <li>资源注册 API
<ul><li><code>Vue.component</code> -&gt; <code>app.component</code></li> <li><code>Vue.directive</code> -&gt; <code>app.directive</code></li></ul></li> <li>拓展行为 API
<ul><li><code>Vue.mixin</code> -&gt; <code>app.mixin</code></li> <li><code>Vue.use</code> -&gt; <code>app.use</code></li></ul></li></ul> <p>所有不会改变 Vue 行为的全局 API 现在都通过命名导出了, 详见<a href="/vue-next-rfc-doc/RFCs/0004-global-api-treeshaking.html">全局 API treeshaking</a>.</p> <p>唯一的例外是 <code>Vue.extend</code>, 因为 <code>Vue</code> 不再是一个可以 new 构造函数, <code>Vue.extend</code> 在构造函数拓展这块就没有什么意义了.</p> <ul><li><p>对于拓展一个普通组件, 应该使用 <code>extends</code> 选项</p></li> <li><p>对于 TypeScript 类型定义, 应该使用新的 <code>defineComponent</code> API:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineComponent<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> App <span class="token operator">=</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">/* 提供类型推断 */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>注意, <code>defineComponent</code> 不会做任何额外操作 - 仅仅返回传入的对象. 不过在类型方面, 返回的对象为 手写 render 函数, JSX 和 IDE 工具支持提供了合成类型.
我们是故意设计成这样的.</p></li></ul> <h3 id="挂载-app-实例"><a href="#挂载-app-实例" class="header-anchor">#</a> 挂载 app 实例</h3> <p>app 实例可以使用 <code>mount</code> 方法挂载一个根组件, 类似于 2.x 的 <code>vm.$mount()</code> 方法, 然后返回已挂载的根组件实例:</p> <div class="language-js extra-class"><pre class="language-js"><code>app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span>App<span class="token punctuation">,</span> <span class="token string">'#app'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 传递给根组件的 props</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="挂载行为与-2-x-的区别"><a href="#挂载行为与-2-x-的区别" class="header-anchor">#</a> 挂载行为与 2.x 的区别</h4> <p>在使用包含编译器的版本时, 挂载一个没有编写模板的根组件, Vue 会尝试使用挂载目标元素的内容作为模板. 3.x 和 2.x 的行为会有以下区别:</p> <ul><li><p>在 2.x 中, 根实例会使用目标元素的<code>outerHTML</code>作为模板, 并替换掉目标元素.</p></li> <li><p>在 3.x 中, 根实例会使用目标元素的<code>innerHTML</code>作为模板, 但只会替换掉目标元素的子元素(children).</p></li></ul> <p>在大部分情况下不会影响你的 app, 唯一的副作用是, 如果目标元素有多个子元素, 根实例会作为一个片段(fragment)挂载, 而<code>this.$el</code>会指向片段(DOM Comment 节点)的开始节点</p> <p>在 Vue 3 中, 由于可以使用 Fragments, 推荐使用模板的 refs 来操作 DOM 节点, 不要使用 <code>this.$el</code>.</p> <h3 id="provide-inject"><a href="#provide-inject" class="header-anchor">#</a> Provide / Inject</h3> <p>app 实例提供的依赖可以被 app 内的任何组件注入:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在入口文件里</span>
app<span class="token punctuation">.</span><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token punctuation">[</span>ThemeSymbol<span class="token punctuation">]</span><span class="token operator">:</span> theme
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 在某个子组件里</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  inject<span class="token operator">:</span> <span class="token punctuation">{</span>
    theme<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">from</span><span class="token operator">:</span> ThemeSymbol
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div :style=&quot;{ color: theme.textColor }&quot; /&gt;</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span>
</code></pre></div><p>这跟在 2.x 的根组件中使用 <code>provide</code> 选项类似.</p> <h3 id="移除-config-productiontip"><a href="#移除-config-productiontip" class="header-anchor">#</a> 移除 <code>config.productionTip</code></h3> <p>在 3.0 中 &quot;use production build&quot; 提示只会在使用 &quot;dev + 完整版本&quot;(包含运行时编译器带警告的版本) 时显示.</p> <p>对于 ES 模块版本, 代码会打包在一起, 而且在大部分情况下 CLI 或 样板文件 已经正确的配置了生产环境, 这个提示也不会在出现.</p> <h3 id="config-ignoredelements-config-iscustomelement"><a href="#config-ignoredelements-config-iscustomelement" class="header-anchor">#</a> <code>config.ignoredElements</code> -&gt; <code>config.isCustomElement</code></h3> <p>引入这个配置是为了支持原生的自定义元素, 因此改名可以更好的表达其意思. 这个新选项需要传入一个函数, 相比旧版只能传入字符串和正则更具灵活性.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 以前</span>
Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>ignoredElements <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'my-el'</span><span class="token punctuation">,</span> <span class="token regex">/^ion-/</span><span class="token punctuation">]</span>

<span class="token comment">// 以后</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">isCustomElement</span> <span class="token operator">=</span> <span class="token parameter">tag</span> <span class="token operator">=&gt;</span> tag<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'ion-'</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>重要提示</strong>: 在 3.0 中, 检测一个元素是否为组件的功能已经移到模板编译阶段, 因此这个配置项只能和运行时编译器同时使用. 如果你使用的是 runtime-only 版本, 那必须在构建配置中将 <code>isCustomElement</code> 传递给 <code>@vue/compiler-dom</code> - 例如: 通过 <a href="https://vue-loader.vuejs.org/zh/options.html#compileroptions" target="_blank" rel="noopener noreferrer"><code>vue-loader</code> 中的 <code>compilerOptions</code> 选项<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <ul><li>如果在使用 runtime-only 版本时配置了 <code>config.isCustomElement</code>, 会抛出一个警告提示用户在构建配置中传递这个选项</li> <li>这会是 Vue CLI 配置中的一个新的顶级选项</li></ul> <h3 id="config-optionmergestrategies-行为变更"><a href="#config-optionmergestrategies-行为变更" class="header-anchor">#</a> <code>config.optionMergeStrategies</code> 行为变更</h3> <p>虽然仍受支持, 但由于 Vue 3 的内部实现变更了, 内置选项不需要合并策略了, 所有不再公开这个 API. <code>app.config.optionMergeStrategies</code>默认是一个空对象, 也就是说:</p> <ul><li>用户必须提供自己的合并策略函数, 无法再复用内置的合并策略了 (例如, 你无法设置 <code>config.optionMergeStrategies.custom = config.optionMergeStrategies.props</code>)</li> <li>无法重写内置的合并策略了</li></ul> <h3 id="添加全局共享实例属性"><a href="#添加全局共享实例属性" class="header-anchor">#</a> 添加全局共享实例属性</h3> <p>在 2.x 中, 可以简单地向<code>Vue.prototype</code>添加属性注入到全局共享的实例.</p> <p>在 Vue 3 中, 由于 <code>Vue</code> 不再是一个构造函数, 所以也不再支持这样做了. 不过, 共享的实例属性应该添加到 app 实例的 <code>config.globalProperties</code> 上.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 之前</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$http</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 之后</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span>config<span class="token punctuation">.</span>globalProperties<span class="token punctuation">.</span><span class="token function-variable function">$http</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h2> <h3 id="插件的自动安装"><a href="#插件的自动安装" class="header-anchor">#</a> 插件的自动安装</h3> <p>许多 Vue 2.x 的库和插件会在其 UMD 版本中提供自动安装功能, 比如: <code>vue-router</code>:</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>https://unpkg.com/vue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>https://unpkg.com/vue-router<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>自动安装需要调用 不再支持的<code>Vue.use</code> 来实现. 这应该是相对容易的迁移, 我们也可以提供一个会抛出警告的 <code>Vue.use</code> 占位代码.</p> <h2 id="备选方案"><a href="#备选方案" class="header-anchor">#</a> 备选方案</h2> <p>N/A</p> <h2 id="升级策略"><a href="#升级策略" class="header-anchor">#</a> 升级策略</h2> <ul><li>转换很简单 (如基本用例所示).</li> <li>移除的方法会被抛出警告的占位代码取代, 以引导迁移.</li> <li>也可以提供 codemod 脚本.</li> <li>至于 <code>config.ingoredElements</code>, 提供兼容垫片也很容易.</li> <li><code>config.ingoredElements</code> 可以在兼容版本中使用.</li> <li><code>config.optionMergeStrategies</code> 内置策略可以在兼容版本中使用.</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-next-rfc-doc/RFCs/0008-render-function-api-change.html" class="prev">
        8. render 函数 API 更改
      </a></span> <span class="next"><a href="/vue-next-rfc-doc/RFCs/0010-optional-props-declaration.html">
        10. 可选的 props 声明
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/vue-next-rfc-doc/assets/js/app.be83df36.js" defer></script><script src="/vue-next-rfc-doc/assets/js/2.fc158681.js" defer></script><script src="/vue-next-rfc-doc/assets/js/15.f2dd0c1d.js" defer></script><script src="/vue-next-rfc-doc/assets/js/3.2d17116a.js" defer></script>
  </body>
</html>
